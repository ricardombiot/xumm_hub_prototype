{"version":3,"file":"bundle.js","mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,KAAqC;AAC/C;AACA;AACA,sUAAsU,CAAM;AAC5U;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,8EAAQ,GAAG;AAC1C;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA,oBAAoB,8EAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C;;;AAGA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;;;AAG3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,KAAqC;AAC/C;AACA;AACA,sUAAsU,CAAM;AAC5U;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;;AAEA;AACA;AACA,iDAAiD;;;AAGjD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,8EAAQ,GAAG;AAC1C;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,8EAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI,KAAqC,+IAA+I,CAAM;;AAE9L;AACA;AACA;AACA,2CAA2C;AAC3C;;;AAGA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI,KAAqC,kJAAkJ,CAAM;;AAEjM;AACA;AACA;AACA,2CAA2C;;;AAG3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,KAAqC,+GAA+G,gBAAgB,qDAAqD,CAAM;AACnO;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,8EAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI,KAAqC,6IAA6I,CAAM;;AAE5L;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI,KAAqC,gJAAgJ,CAAM;;AAE/L;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEuG;AACvG;;;;;;;;;;;;AC5xBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/C4D;AACgB;AACpD;AACe;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,WAAW,yDAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;;AAEA,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAoB;AACjC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,iFAAiF,gDAAgD,wHAAwH,gBAAgB,WAAW,qBAAqB,4BAA4B,cAAc,SAAS,mCAAmC;AAC7b,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;AAC7S,uCAAuC,uDAAuD,uCAAuC,SAAS,uBAAuB;AACrK,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kGAAkG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,4BAA4B;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX;AACA,6DAA6D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACrS,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kDAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kDAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,CAAC,8CAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,wCAAwC,kDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAoB;AACxC;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAiB;AACrC;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAmB;AACvC;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX;AACA,6DAA6D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACrS,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX;AACA,6DAA6D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACrS;AACA,wBAAwB,kDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,kDAAS;AACvE;AACA;AACA,qBAAqB,kDAAS;AAC9B;AACA;AACA,GAAG;AACH,SAAS,oDAAW;AACpB;;AAEA;AACA,6DAA6D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,SAAS,6DAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,kDAAkD,0DAA0D,2CAA2C;AACvJ,mCAAmC,4GAA4G,iBAAiB,aAAa;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX,gDAAgD,0DAA0D,2CAA2C;AACrJ,iCAAiC,0GAA0G,iBAAiB,aAAa;AACzK;AACA;AACA;AACA;AACA,SAAS,kDAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAS;;AAEX;AACA,2DAA2D,+BAA+B,iBAAiB,sCAAsC,YAAY,YAAY,uBAAuB,OAAO,qBAAqB,0CAA0C,6BAA6B;AACnS;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6DAAoB;AAC/B;AACA,eAAe,6DAAoB;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS,gEAAoB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5hCrO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;AAE4iB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzsExgB;;AAEpC,IAAI,IAAqC;AACzC;AACA;;;;;;;;;;;ACJA;AACA;AACA;;;;;;;;;;;ACFA,mBAAmB,mBAAO,CAAC,8DAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,+BAA+B;AAC/B,6BAA6B;AAC7B,yBAAyB;;;;;;;;;;;ACVzB,cAAc,mBAAO,CAAC,gDAAS;;AAE/B;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,+BAA+B;AAC/B,6BAA6B;;AAE7B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY;AACZ;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B,YAAY;AACZ;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E;AACA,YAAY,uBAAuB;AACnC,YAAY,uBAAuB;AACnC,YAAY,uBAAuB;AACnC,YAAY;AACZ;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;;AAEA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA,oCAAoC,QAAQ,sBAAsB,QAAQ;AAC1E;;AAEA,mCAAmC,QAAQ,sBAAsB,QAAQ;AACzE;;;;;;;;;;;;;;;;;;;ACzakE;AAC3D;AACP;AACA,qBAAqB,8DAAc;AACnC;AACA;AACO;AACP,0BAA0B,OAAO;AACjC,qBAAqB,8DAAc;AACnC;AACA;AACO;AACP;AACA,qBAAqB,+DAAe;AACpC;AACA;;;;;;;;;;;;;;;;;;ACfkD;AAC3C;AACP;AACA;AACA;AACA;AACA,qBAAqB,+DAAe;AACpC;AACA;AACO;AACP;AACA,qBAAqB,+DAAe;AACpC;AACA;;;;;;;;;;;;;;;;;;;;ACbA,0BAA0B;AACnB;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACnCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXqD;AAC9C,kBAAkB,8DAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBqD;AAC9C,wBAAwB,8DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBqD;AACrD;AACA;AACO,uBAAuB,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI,QAAQ,IAAI,QAAQ,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1Ce;AACf;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCbA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA,sBAAsB;UACtB,oDAAoD,uBAAuB;UAC3E;UACA;UACA,GAAG;UACH;UACA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;;;;;WCxCA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;;;;;WCJA;;;;;WCAA;;;;;WCAA;;;;;WCAA;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;;WAED;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA,2BAA2B;WAC3B,4BAA4B;WAC5B,2BAA2B;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;WACA,oBAAoB,gBAAgB;WACpC;WACA;WACA;WACA,KAAK;WACL;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,oBAAoB,gBAAgB;WACpC;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA,iBAAiB,qCAAqC;WACtD;;WAEA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA,oBAAoB,iBAAiB;WACrC;WACA;WACA;WACA,GAAG;WACH;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA,QAAQ;WACR;WACA;WACA,QAAQ;WACR;WACA,MAAM;WACN,KAAK;WACL,IAAI;WACJ,GAAG;WACH;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;;WAEA;WACA;;WAEA;;WAEA;WACA;WACA,EAAE;WACF;;WAEA;WACA;WACA;WACA,GAAG;WACH;;WAEA;WACA;WACA;WACA,GAAG;WACH;;WAEA;WACA;;WAEA;WACA;WACA,EAAE;;WAEF;WACA;;WAEA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,oBAAoB,oBAAoB;WACxC;WACA;WACA;WACA;WACA,EAAE;;WAEF;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;;WAEA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA,IAAI;WACJ;;WAEA;WACA;WACA,GAAG;WACH,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ,GAAG;WACH;WACA;WACA;WACA;;;;;WCrYA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mBAAmB,2BAA2B;WAC9C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,kBAAkB,cAAc;WAChC;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,cAAc,MAAM;WACpB;WACA;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA,cAAc,aAAa;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA,iBAAiB,4BAA4B;WAC7C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;;WAEA;;WAEA;WACA;WACA;WACA;WACA,IAAI;WACJ;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA,gBAAgB,4BAA4B;WAC5C;WACA;WACA;;WAEA;WACA;;WAEA;WACA;;WAEA;WACA;;WAEA;WACA,gBAAgB,4BAA4B;WAC5C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,kBAAkB,uCAAuC;WACzD;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,mBAAmB,iCAAiC;WACpD;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sBAAsB,uCAAuC;WAC7D;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sBAAsB,sBAAsB;WAC5C;WACA;WACA,SAAS;WACT;WACA;WACA;WACA;WACA;WACA,WAAW;WACX,WAAW;WACX;WACA;WACA;WACA;WACA;WACA;WACA;WACA,YAAY;WACZ;WACA;WACA;WACA;WACA;WACA;WACA,UAAU;WACV;WACA;WACA;WACA;WACA;WACA;WACA,WAAW;WACX;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,mBAAmB,wCAAwC;WAC3D;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA,QAAQ;WACR,QAAQ;WACR;WACA;WACA;WACA;WACA;WACA;WACA,SAAS;WACT;WACA;WACA;WACA;WACA;WACA;WACA,OAAO;WACP;WACA;WACA;WACA;WACA;WACA,QAAQ;WACR;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE,IAAI;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,EAAE;WACF;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,sCAAsC;WACtC;WACA;WACA,EAAE;WACF;;WAEA;;WAEA;;;;;UE9fA;UACA;UACA;UACA","sources":["webpack://inferno-boilerplate/./src/MyApp.js","webpack://inferno-boilerplate/./src/MyHome.js","webpack://inferno-boilerplate/./src/VersionComponent.js","webpack://inferno-boilerplate/./src/components/job/JobForm.js","webpack://inferno-boilerplate/./src/components/job/JobPage.js","webpack://inferno-boilerplate/./src/components/job/JobRow.js","webpack://inferno-boilerplate/./src/components/job/JobsList.js","webpack://inferno-boilerplate/./src/components/quotation/QuotationForm.js","webpack://inferno-boilerplate/./src/components/quotation/QuotationPage.js","webpack://inferno-boilerplate/./src/components/quotation/QuotationsListForAdmin.js","webpack://inferno-boilerplate/./src/components/utils/XRPInput.js","webpack://inferno-boilerplate/./src/index.js","webpack://inferno-boilerplate/./node_modules/history/index.js","webpack://inferno-boilerplate/./node_modules/hoist-non-inferno-statics/index.js","webpack://inferno-boilerplate/./node_modules/inferno-router/dist/index.esm.js","webpack://inferno-boilerplate/./node_modules/inferno/dist/index.esm.js","webpack://inferno-boilerplate/./node_modules/inferno/index.esm.js","webpack://inferno-boilerplate/./node_modules/isarray/index.js","webpack://inferno-boilerplate/./node_modules/path-to-regexp-es6/index.js","webpack://inferno-boilerplate/./node_modules/path-to-regexp/index.js","webpack://inferno-boilerplate/./src/api/api_jobs.ts","webpack://inferno-boilerplate/./src/api/api_quotations.ts","webpack://inferno-boilerplate/./src/api/api_with_auth.ts","webpack://inferno-boilerplate/./src/models/inmmutable_model.ts","webpack://inferno-boilerplate/./src/models/job.ts","webpack://inferno-boilerplate/./src/models/quotation.ts","webpack://inferno-boilerplate/./src/models/xrp.ts","webpack://inferno-boilerplate/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://inferno-boilerplate/webpack/bootstrap","webpack://inferno-boilerplate/webpack/runtime/compat get default export","webpack://inferno-boilerplate/webpack/runtime/define property getters","webpack://inferno-boilerplate/webpack/runtime/get javascript update chunk filename","webpack://inferno-boilerplate/webpack/runtime/get update manifest filename","webpack://inferno-boilerplate/webpack/runtime/getFullHash","webpack://inferno-boilerplate/webpack/runtime/hasOwnProperty shorthand","webpack://inferno-boilerplate/webpack/runtime/load script","webpack://inferno-boilerplate/webpack/runtime/make namespace object","webpack://inferno-boilerplate/webpack/runtime/hot module replacement","webpack://inferno-boilerplate/webpack/runtime/publicPath","webpack://inferno-boilerplate/webpack/runtime/jsonp chunk loading","webpack://inferno-boilerplate/webpack/before-startup","webpack://inferno-boilerplate/webpack/startup","webpack://inferno-boilerplate/webpack/after-startup"],"sourcesContent":["import VersionComponent from './VersionComponent.js';\n\nexport default function MyApp({children}) {\n    return (\n        <div>\n            <h1>Inferno Boilerplate</h1>\n            {children}\n        </div>\n    );\n}\n","import { Component } from 'inferno';\nimport JobsList from \"./components/job/JobsList\";\n\nclass MyHome extends Component {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n      return <div>\n            <JobsList />\n        </div>\n    }\n}\n\n\nexport default MyHome;","import {version} from 'inferno';\n\nfunction showVersion() {\n    alert(`The version is: ${version}!`);\n}\n\nexport default function VersionComponent() {\n    return (\n        <div>\n            <p>This is an Inferno Boilerplate example using <em>Inferno {version}</em>.</p>\n            <button onClick={showVersion}>Show version</button>\n        </div>\n    );\n}\n","import { linkEvent, Component } from \"inferno\";\nimport { Job } from \"../../models/job\";\nimport { register_new_job } from \"../../api/api_jobs\";\n\n\nexport default class JobForm extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n          was_send: false,\n          job: Job.default()\n        }\n\n\n        this.handleChangeTitle = this.handleChangeTitle.bind(this);\n        this.handleChangeBudget = this.handleChangeBudget.bind(this);\n        this.handleChangeDescription = this.handleChangeDescription.bind(this);\n\n        this.handleSubmit = this.handleSubmit.bind(this);\n\n    }\n    \n    handleChangeTitle(event) {      \n      let new_job = this.state.job.clone();\n      new_job.setTitle(event.target.value)\n      this.setState({job: new_job});\n    }\n\n    handleChangeBudget(event) {\n      let new_job = this.state.job.clone();\n      //@TODO Not run, should take select range.\n      new_job.setBudgetRange(event.target.value);\n      this.setState({job: new_job});\n    }\n\n    handleChangeDescription(event) {\n      let new_job = this.state.job.clone();\n      new_job.setDescription(event.target.value)\n      this.setState({job: new_job});\n    }\n\n    handleSubmit(event) {\n      this.setState({was_send: true});\n\n      register_new_job(this.state.job.raw()).then((result) => {\n        let new_job_id = result.id\n        window.location.href = \"/job/\" + new_job_id;\n      })\n\n      event.preventDefault();\n    }\n  \n\n    render(){      \n        if(this.state.was_send) {\n          return (<div class=\"spinner-border text-primary\" role=\"status\">\n          <span class=\"sr-only\">Loading...</span>\n        </div>);\n        }else{\n          return (\n            <form onSubmit={this.handleSubmit}>\n            <div class=\"m-5\">\n              <h1>New Job</h1>\n              <div class=\"form-group\">\n                <label>Title</label>\n                <input type=\"text\" class=\"form-control\" id=\"job_title\" placeholder=\"\" value={this.state.job.title} onInput={this.handleChangeTitle}></input>\n              </div>\n              <div class=\"form-group\">\n                <label>Budget</label>\n                <select class=\"form-control\" id=\"job_bugdet_range\" onInput={this.handleChangeBudget}>\n                  <option>less 1000 XRP</option>\n                  <option selected=\"true\">1000 - 3000 XRP</option>\n                  <option>3000 - 6000 XRP</option>\n                  <option>+ 10000 XRP</option>\n                </select>\n              </div>\n              <div class=\"form-group\">\n                <label for=\"exampleFormControlSelect2\">Categories</label>\n                <p># Selector categories...</p>\n              </div>\n              <div class=\"form-group\">\n                <label>Description</label>\n                <textarea class=\"form-control\" id=\"job_description\" rows=\"5\" value={this.state.job.description} onInput={this.handleChangeDescription}></textarea>\n              </div>\n              <input type=\"submit\" value=\"Submit\" />\n            </div>\n            </form>\n        );\n        }\n\n\n    }\n\n}\n\n\n\n","import { Component } from 'inferno';\nimport { get_job } from './../../api/api_jobs';\nimport JobRow from './JobRow';\nimport QuotationForm  from \"./../quotation/QuotationForm\";\nimport QuotationsListForAdmin  from \"./../quotation/QuotationsListForAdmin\";\n\nclass JobPage extends Component {\n    constructor(props) {\n        super(props);\n        let params = props.match.params;\n\n        this.state = {\n            job: \"NOT_LOADED\",\n            job_id: params.job_id \n        };\n    }\n\n    componentDidMount(){\n        get_job(this.state.job_id).then((job) => {\n            console.log(job);\n            this.setState({job: job})\n        })\n    }\n\n    _render_job(){\n        if(this.state.job == \"NOT_LOADED\") {\n            return (<div class=\"spinner-border text-primary\" role=\"status\">\n            <span class=\"sr-only\">Loading...</span>\n          </div>);\n        }else{\n            return  (\n                <div>\n                    <JobRow data={this.state.job}></JobRow>\n                    <QuotationForm job_id={this.state.job.id}></QuotationForm>\n                    <QuotationsListForAdmin job_id={this.state.job.id} payer_id={this.state.job.payer.id}></QuotationsListForAdmin>\n                </div>\n            )\n        }\n       \n    }\n\n    render() {\n        return (<div>\n                <h1>Job Page: {this.state.job_id}</h1>\n                {this._render_job()}\n            </div>)\n    }\n}\n\n\nexport default JobPage;","import { Component } from \"inferno\";\nimport { Link } from \"inferno-router\";\nimport { session_is_owner } from \"./../../api/api_with_auth\";\n\nexport default class JobRow extends Component {\n    constructor(props) {\n        super(props)\n    }\n\n    render(){\n        const { data } = this.props; // Recibimos el objeto Job como prop\n        const url_job = \"/job/\" + data.id;\n        const text_owner = session_is_owner(data.payer.id) ? \"(OWNER)\": \"\"\n\n        return (\n            <div className=\"card text-center\">\n                <div className=\"card-header custom-background\">\n                    {data.title} {text_owner}\n                </div>\n                <div className=\"card-body\">\n                    <p className=\"card-text\">{data.description}</p> \n                </div>\n                <div className=\"card-footer text-muted custom-background\">\n                    2 days ago <Link to={url_job}> See more </Link>\n                </div>\n            </div>\n        );\n    }\n\n}\n","import { Component } from 'inferno';\nimport { Link } from 'inferno-router';\nimport { get_list_jobs } from './../../api/api_jobs';\nimport JobRow from './JobRow';\n\nexport default class JobsList extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n          data: []\n        }\n    }\n\n    componentDidMount() {\n        get_list_jobs()\n        .then(list_jobs => {\n            this.setState({ data: list_jobs });\n        })\n        .catch(error => {\n            console.error('Error fetching data:', error);\n        });\n    }\n\n    _render_jobs(){\n        let jobs = this.state.data;\n        let jobElements = [];\n    \n        for (let index = 0; index < jobs.length; index++) {\n            const job = jobs[index];\n            jobElements.push(<JobRow key={job.id} data={job}/>);\n        }\n    \n        return jobElements;\n    }\n\n    render() {\n      return <div class=\"m-5\">\n            <h1>Jobs list</h1>\n            <Link to=\"/job/new\" class=\"btn btn-outline-primary\">New Job</Link>\n            <div id=\"list\">\n            {this._render_jobs()}\n            </div>\n        </div>\n    }\n}\n","import { Component } from 'inferno';\nimport { Quotation } from './../../models/quotation';\nimport { register_new_quotation } from \"./../../api/api_quotations\"; \nimport XRPInput from './../utils/XRPInput';\n\nexport default class QuotationForm extends Component {\n    constructor(props) {\n        super(props);\n        const { job_id } = this.props;\n        console.log(\"QuotationForm JobId: \" + job_id);\n\n        this.state = {\n            quotation: Quotation.default(job_id)\n        }\n\n        this.handleChangeDescription = this.handleChangeDescription.bind(this);\n        this.handleUpdateTotalAmount = this.handleUpdateTotalAmount.bind(this);\n\n        this.handleSubmit = this.handleSubmit.bind(this);\n    }\n\n    handleChangeDescription(event){\n        let new_quotation = this.state.quotation.clone();\n        new_quotation.setDescription(event.target.value);\n        this.setState({quotation: new_quotation});\n    }\n\n    handleUpdateTotalAmount(amount){\n        //console.log(\"updateAmount\");\n        this.state.quotation.setTotalAmount(amount.data.value);\n    }\n\n    handleSubmit(event){\n        let quotation = this.state.quotation.raw();\n\n        register_new_quotation(this.state.quotation.raw()).then((result) => {\n            let redirect_url = `${quotation.job_id}/quote/${result.id}`; \n            window.location.href = redirect_url;\n        })\n\n        event.preventDefault();\n    }\n\n    render() {\n      return <div>\n            <form onSubmit={this.handleSubmit}>\n            <div class=\"m-5\">\n              <h1>Quotation</h1>\n              <div class=\"form-group\">\n                <label>Description</label>\n                <textarea class=\"form-control\" id=\"quotation_description\" rows=\"5\" value={this.state.quotation.description} onInput={this.handleChangeDescription}></textarea>\n              </div>\n              <div class=\"form-group\">\n                <label>Total amount</label>\n                <XRPInput afterUpdate={this.handleUpdateTotalAmount}></XRPInput>\n              </div>\n              <input type=\"submit\" value=\"Submit\" />\n            </div>\n            </form>\n        </div>\n    }\n}\n","import { Component } from 'inferno';\n\nexport default class QuotationPage extends Component {\n    constructor(props) {\n        super(props);\n        let params = props.match.params;\n\n        this.state = {\n            quotation: \"NOT_LOADED\",\n            job_id: params.job_id,\n            quotation_id: params.quotation_id\n        };\n    }\n\n    componentDidMount(){\n       /* get_job(this.state.job_id).then((job) => {\n            console.log(job);\n            this.setState({job: job})\n        })*/\n    }\n\n    render() {\n        return (<div>\n                <h1>Job id: {this.state.job_id} Quote: {this.state.quotation_id}</h1>\n            </div>)\n    }\n}\n\n","import { Component } from 'inferno';\nimport { session_is_owner } from \"./../../api/api_with_auth\";\nimport { list_quotation_by_job } from \"./../../api/api_quotations\";\n\nexport default class QuotationsListForAdmin extends Component {\n    constructor(props) {\n        super(props);\n\n        const { job_id, payer_id } = this.props;\n\n        this.state = {quotations: []};\n       \n        if(session_is_owner(payer_id)){\n            console.log(\"QuotationList JobId: \" + job_id + \"OWNER\");\n        }else{\n            console.log(\"QuotationList JobId: \" + job_id + \"NOT OWNER\");\n        }\n    }\n\n\n    componentDidMount(){\n        list_quotation_by_job(this.state.job_id).then((quotations) => {\n            this.setState({quotations: quotations})\n        })\n    }\n\n    _render_quotes(){\n        let quotes = this.state.quotations;\n        let quotesElements = [];\n    \n        for (let index = 0; index < quotes.length; index++) {\n            const quote = quotes[index];\n            let html = <div>{quote.id}</div>\n            quotesElements.push(html);\n        }\n    \n        return quotesElements;\n    }\n\n    render() {\n        const { job_id, payer_id } = this.props;\n\n        if(session_is_owner(payer_id)){\n            return (<div id=\"admin_quotations_list\">\n                {this._render_quotes()}\n            </div>)\n        }else{\n            return []\n        }\n    }\n}\n","import { Component } from 'inferno';\n\nimport { XRPValue } from './../../models/xrp';\n\n\nexport default class XRPInput extends Component {\n    constructor(props) {\n        super(props);\n\n        let {label , afterUpdate } = props;\n\n        this.state = {\n            label: label,\n            amount: XRPValue.default(\"1.0\"),\n            afterUpdate: afterUpdate\n        }\n\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event){\n        let new_amount = this.state.amount.clone();\n        new_amount.trySetValueFromStr(event.target.value);\n        this.setState({amount: new_amount});\n    }\n\n    componentDidUpdate(){\n        this.state.afterUpdate(this.state.amount);\n    }\n\n    render() {\n        return ( \n        <div class=\"xrp-input\">\n            <input type=\"text\" placeholder=\"0.1\" value={this.state.amount.data.value_txt} onInput={this.handleChange}></input>\n            <em class=\"xrp-input-tag\">XRP</em>\n            <em class=\"xrp-input-dolars\">estimation {this.state.amount.data.on_dolars} $</em>\n        </div>)\n    }\n\n}\n","// inferno module\nimport {render} from 'inferno';\n\n// routing modules\nimport {BrowserRouter, Switch, Link, Route} from 'inferno-router';\nimport {createBrowserHistory} from 'history';\nimport MyApp from './MyApp';\nimport MyHome from './MyHome';\nimport JobForm from './components/job/JobForm';\nimport JobPage from './components/job/JobPage';\nimport QuotationPage  from './components/quotation/QuotationPage';\n//import { xumm_main } from './xumm_app';\n\nconst browserHistory = createBrowserHistory();\n\nfunction App({children}) {\n    return (\n        <div>\n            <h1>Application</h1>\n            {children}\n        </div>\n    );\n}\n\nfunction NoMatch({children, params}) {\n    return <div>no match</div>;\n}\n\nfunction Home({children}) {\n    return <div>home</div>;\n}\n\n// `children` in this case will be the `User` component\nfunction Users({match}) {\n    return (\n        <div>\n            <h2>user list</h2>\n            <Route path={match.url + '/user/:username'} component={User}/>\n        </div>\n    );\n}\n\nfunction JobRouter({match}) {\n    return (\n        <div id=\"job_router\">\n            <Switch>\n                <Route path={match.url + '/new'} component={JobForm}/>\n                <Route path={match.url + '/:job_id/quote/:quotation_id'} component={QuotationPage}/>\n                <Route path={match.url + '/:job_id'} component={JobPage}/>\n            </Switch>\n        </div>\n    );\n}\n\nfunction User({match}) {\n    return <h1>{JSON.stringify(match.params)}</h1>;\n}\n\nconst routes = (\n    <BrowserRouter history={browserHistory}>\n        <div>\n            <h1>Application</h1>\n            <Switch>\n                <Route exact path=\"/\" component={MyHome}/>\n                <Route path=\"/job\" component={JobRouter}/>\n\n                <Route path=\"/users\" component={Users}/>\n                <Route path=\"/my-app\" component={MyApp}/>\n                <Route path=\"*\" component={NoMatch}/>\n            </Switch>\n        </div>\n    </BrowserRouter>\n);\n\n\nfunction main(){\n    console.log(\"ready inferno... APP\");\n    render(routes, document.getElementById('app'));\n}\n\nwindow.main_inferno = function(){\n    main();\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nvar INFERNO_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!INFERNO_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\nmodule.exports = hoistNonReactStatics;\nmodule.exports.default = module.exports;\n","import { createComponentVNode, Component, linkEvent, createVNode } from 'inferno';\nimport { parsePath, createBrowserHistory, createHashHistory, createMemoryHistory } from 'history';\nimport pathToRegexp from 'path-to-regexp-es6';\nimport hoistNonReactStatics from 'hoist-non-inferno-statics';\n\nvar isArray = Array.isArray;\nfunction isNullOrUndef(o) {\n  return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\nfunction isString(o) {\n  return typeof o === 'string';\n}\nfunction isUndefined(o) {\n  return o === void 0;\n}\nfunction combineFrom(first, second) {\n  var out = {};\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n  if (second) {\n    for (var _key in second) {\n      out[_key] = second[_key];\n    }\n  }\n  return out;\n}\n\nfunction combinePath(_ref) {\n  var _ref$pathname = _ref.pathname,\n    pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n    _ref$search = _ref.search,\n    search = _ref$search === void 0 ? '' : _ref$search,\n    _ref$hash = _ref.hash,\n    hash = _ref$hash === void 0 ? '' : _ref$hash;\n  return pathname + search + hash;\n}\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n  if (cache[pattern]) {\n    return cache[pattern];\n  }\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = {\n    re: re,\n    keys: keys\n  };\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n  return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nfunction matchPath(pathname, options) {\n  if (typeof options === 'string') {\n    options = {\n      path: options\n    };\n  }\n  var _options = options,\n    _options$path = _options.path,\n    path = _options$path === void 0 ? '/' : _options$path,\n    _options$exact = _options.exact,\n    exact = _options$exact === void 0 ? false : _options$exact,\n    _options$strict = _options.strict,\n    strict = _options$strict === void 0 ? false : _options$strict,\n    _options$sensitive = _options.sensitive,\n    sensitive = _options$sensitive === void 0 ? false : _options$sensitive,\n    loader = _options.loader,\n    _options$initialData = _options.initialData,\n    initialData = _options$initialData === void 0 ? {} : _options$initialData;\n  var _compilePath = compilePath(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n    re = _compilePath.re,\n    keys = _compilePath.keys;\n  var match = re.exec(pathname);\n  if (!match) {\n    return null;\n  }\n  var loaderData = initialData[path];\n  var url = match[0],\n    values = match.slice(1);\n  var isExact = pathname === url;\n  if (exact && !isExact) {\n    return null;\n  }\n  return {\n    isExact: isExact,\n    loader: loader,\n    loaderData: loaderData,\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {}),\n    path: path,\n    url: path === '/' && url === '' ? '/' : url // the matched portion of the URL\n  };\n}\n\nfunction _inheritsLoose$8(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$8(subClass, superClass); }\nfunction _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }\nfunction getMatch(pathname, _ref, router) {\n  var _path;\n  var path = _ref.path,\n    exact = _ref.exact,\n    strict = _ref.strict,\n    sensitive = _ref.sensitive,\n    loader = _ref.loader,\n    from = _ref.from;\n  (_path = path) != null ? _path : path = from;\n  var initialData = router.initialData,\n    route = router.route; // This is the parent route\n  return path ? matchPath(pathname, {\n    path: path,\n    exact: exact,\n    strict: strict,\n    sensitive: sensitive,\n    loader: loader,\n    initialData: initialData\n  }) : route.match;\n}\nfunction extractFirstMatchFromChildren(pathname, children, router) {\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; ++i) {\n      var nestedMatch = extractFirstMatchFromChildren(pathname, children[i], router);\n      if (nestedMatch.match) return nestedMatch;\n    }\n    return {};\n  }\n  return {\n    _child: children,\n    match: getMatch(pathname, children.props, router)\n  };\n}\nvar Switch = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$8(Switch, _Component);\n  function Switch(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    var router = context.router;\n    var location = props.location,\n      children = props.children;\n    var pathname = (location || router.route.location).pathname;\n    var _extractFirstMatchFro = extractFirstMatchFromChildren(pathname, children, router),\n      match = _extractFirstMatchFro.match,\n      _child = _extractFirstMatchFro._child;\n    _this.state = {\n      _child: _child,\n      match: match\n    };\n    return _this;\n  }\n  var _proto = Switch.prototype;\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    var router = nextContext.router;\n    var location = nextProps.location,\n      children = nextProps.children;\n    var pathname = (location || router.route.location).pathname;\n    var _extractFirstMatchFro2 = extractFirstMatchFromChildren(pathname, children, router),\n      match = _extractFirstMatchFro2.match,\n      _child = _extractFirstMatchFro2._child;\n    this.setState({\n      match: match,\n      _child: _child\n    });\n  };\n  _proto.render = function render(_ref2, _ref3, context) {\n    var children = _ref2.children,\n      location = _ref2.location;\n    var match = _ref3.match,\n      _child = _ref3._child;\n    if (isInvalid(children)) {\n      return null;\n    }\n    if (match) {\n      var _location;\n      (_location = location) != null ? _location : location = context.router.route.location;\n      return createComponentVNode(_child.flags, _child.type, combineFrom(_child.props, {\n        location: location,\n        computedMatch: match\n      }));\n    }\n    return null;\n  };\n  return Switch;\n}(Component);\n\nfunction resolveLoaders(loaderEntries) {\n  var promises = loaderEntries.map(function (_ref) {\n    var path = _ref.path,\n      params = _ref.params,\n      request = _ref.request,\n      loader = _ref.loader;\n    return resolveEntry(path, params, request, loader);\n  });\n  return Promise.all(promises).then(function (result) {\n    return Object.fromEntries(result);\n  });\n}\nfunction traverseLoaders(location, tree, base) {\n  return _traverseLoaders(location, tree, base, false);\n}\n// Optionally pass base param during SSR to get fully qualified request URI passed to loader in request param\nfunction _traverseLoaders(location, tree, base, parentIsSwitch) {\n  var _tree$props4, _tree$type;\n  if (parentIsSwitch === void 0) {\n    parentIsSwitch = false;\n  }\n  // Make sure tree isn't null\n  if (isNullOrUndef(tree)) return [];\n  if (Array.isArray(tree)) {\n    var hasMatch = false;\n    var entriesOfArr = tree.reduce(function (res, node) {\n      var _node$type;\n      if (parentIsSwitch && hasMatch) return res;\n      var outpArr = _traverseLoaders(location, node, base, (node == null ? void 0 : (_node$type = node.type) == null ? void 0 : _node$type.prototype) instanceof Switch);\n      if (parentIsSwitch && outpArr.length > 0) {\n        hasMatch = true;\n      }\n      return [].concat(res, outpArr);\n    }, []);\n    return entriesOfArr;\n  }\n  var outp = [];\n  var isRouteButNotMatch = false;\n  if (tree.props) {\n    var _tree$props2, _tree$props3;\n    // TODO: If we traverse a switch, only the first match should be returned\n    // TODO: Should we check if we are in Router? It is defensive and could save a bit of time, but is it worth it?\n    var _tree$props = tree.props,\n      path = _tree$props.path,\n      _tree$props$exact = _tree$props.exact,\n      exact = _tree$props$exact === void 0 ? false : _tree$props$exact,\n      _tree$props$strict = _tree$props.strict,\n      strict = _tree$props$strict === void 0 ? false : _tree$props$strict,\n      _tree$props$sensitive = _tree$props.sensitive,\n      sensitive = _tree$props$sensitive === void 0 ? false : _tree$props$sensitive;\n    var match = matchPath(location, {\n      exact: exact,\n      path: path,\n      sensitive: sensitive,\n      strict: strict\n    });\n    // So we can bail out of recursion it this was a Route which didn't match\n    isRouteButNotMatch = !match;\n    // Add any loader on this node (but only on the VNode)\n    if (match && !tree.context && (_tree$props2 = tree.props) != null && _tree$props2.loader && (_tree$props3 = tree.props) != null && _tree$props3.path) {\n      var params = match.params;\n      var controller = new AbortController();\n      var request = createClientSideRequest(location, controller.signal, base);\n      outp.push({\n        controller: controller,\n        loader: tree.props.loader,\n        params: params,\n        path: path,\n        request: request\n      });\n    }\n  }\n  // Traverse ends here\n  if (isRouteButNotMatch) return outp;\n  // Traverse children\n  var entries = _traverseLoaders(location, tree.children || ((_tree$props4 = tree.props) == null ? void 0 : _tree$props4.children), base, ((_tree$type = tree.type) == null ? void 0 : _tree$type.prototype) instanceof Switch);\n  return [].concat(outp, entries);\n}\nfunction resolveEntry(path, params, request, loader) {\n  return loader({\n    params: params,\n    request: request\n  }).then(function (res) {\n    // This implementation is based on:\n    // https://github.com/remix-run/react-router/blob/4f3ad7b96e6e0228cc952cd7eafe2c265c7393c7/packages/router/router.ts#L2787-L2879\n    // Check if regular data object (from tests or initialData)\n    if (typeof res.json !== 'function') {\n      return [path, {\n        res: res\n      }];\n    }\n    var contentType = res.headers.get('Content-Type');\n    var dataPromise;\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      dataPromise = res.json();\n    } else {\n      dataPromise = res.text();\n    }\n    return dataPromise.then(function (body) {\n      // We got a JSON error\n      if (!res.ok) {\n        return [path, {\n          err: body\n        }];\n      }\n      // We got JSON response\n      return [path, {\n        res: body\n      }];\n    })\n    // Could not parse JSON\n    [\"catch\"](function (err) {\n      return [path, {\n        err: err\n      }];\n    });\n  })\n  // Could not fetch data\n  [\"catch\"](function (err) {\n    return [path, {\n      err: err\n    }];\n  });\n}\nvar inBrowser = typeof window === 'undefined';\nfunction createClientSideRequest(location, signal,\n// submission?: Submission\nbase) {\n  var url = inBrowser || !isUndefined(base) ? createClientSideURL(location, base) : location.toString();\n  var init = {\n    signal: signal\n  };\n  // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n  return new Request(url, init);\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction createClientSideURL(location, base) {\n  if (base === undefined && typeof window !== 'undefined') {\n    var _window, _window$location;\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    base = ((_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.origin) !== 'null' ? window.location.origin : window.location.href;\n  }\n  var url = new URL(location.toString(), base);\n  url.hash = '';\n  return url;\n}\n// TODO: react-router supports submitting forms with loaders, this is related to that\n// function isMutationMethod(method?: string): method is MutationFormMethod {\n//   return validMutationMethods.has(method as MutationFormMethod);\n// }\n// function convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n//   let searchParams = new URLSearchParams();\n//   for (let [key, value] of formData.entries()) {\n//     // invariant(\n//     //   typeof value === \"string\",\n//     //   'File inputs are not supported with encType \"application/x-www-form-urlencoded\", ' +\n//     //     'please use \"multipart/form-data\" instead.'\n//     // );\n//     if (typeof value === \"string\") {\n//       searchParams.append(key, value);\n//     }\n//   }\n//   return searchParams;\n// }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _inheritsLoose$7(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$7(subClass, superClass); }\nfunction _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }\n/**\n * The public API for putting history on context.\n */\nvar Router = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$7(Router, _Component);\n  function Router(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    _this.unlisten = void 0;\n    _this._loaderFetchControllers = [];\n    _this._loaderIteration = 0;\n    var match = _this.computeMatch(props.history.location.pathname);\n    _this.state = {\n      initialData: _this.props.initialData,\n      match: match\n    };\n    return _this;\n  }\n  var _proto = Router.prototype;\n  _proto.getChildContext = function getChildContext() {\n    var _this$state, _this$state2;\n    var parentRouter = this.context.router;\n    var router = combineFrom(parentRouter, null);\n    router.history = this.props.history;\n    router.route = {\n      location: router.history.location,\n      match: (_this$state = this.state) == null ? void 0 : _this$state.match // Why are we sending this? it appears useless.\n    };\n\n    router.initialData = (_this$state2 = this.state) == null ? void 0 : _this$state2.initialData; // this is a dictionary of all data available\n    return {\n      router: router\n    };\n  };\n  _proto.computeMatch = function computeMatch(pathname) {\n    return {\n      isExact: pathname === '/',\n      loader: undefined,\n      params: {},\n      path: '/',\n      url: '/'\n    };\n  };\n  _proto.componentWillMount = function componentWillMount() {\n    var _this2 = this;\n    var history = this.props.history;\n    // Do this here so we can setState when a <Redirect> changes the\n    // location in componentWillMount. This happens e.g. when doing\n    // server rendering using a <StaticRouter>.\n    this.unlisten = history.listen(function () {\n      var match = _this2.computeMatch(history.location.pathname);\n      _this2._matchAndResolveLoaders(match);\n    });\n    // First execution of loaders\n    if (isUndefined(this.props.initialData)) {\n      var _this$state3;\n      this._matchAndResolveLoaders((_this$state3 = this.state) == null ? void 0 : _this$state3.match);\n    }\n  };\n  _proto._matchAndResolveLoaders = function _matchAndResolveLoaders(match) {\n    var _this3 = this;\n    // Keep track of invokation order\n    // Bumping the counter needs to be done first because calling abort\n    // triggers promise to resolve with \"aborted\"\n    this._loaderIteration = (this._loaderIteration + 1) % 10000;\n    var currentIteration = this._loaderIteration;\n    for (var _iterator = _createForOfIteratorHelperLoose(this._loaderFetchControllers), _step; !(_step = _iterator()).done;) {\n      var controller = _step.value;\n      controller.abort();\n    }\n    this._loaderFetchControllers = [];\n    var _this$props = this.props,\n      history = _this$props.history,\n      children = _this$props.children;\n    var loaderEntries = traverseLoaders(history.location.pathname, children);\n    if (loaderEntries.length === 0) {\n      this.setState({\n        match: match\n      });\n      return;\n    }\n    // Store AbortController instances for each matched loader\n    this._loaderFetchControllers = loaderEntries.map(function (e) {\n      return e.controller;\n    });\n    resolveLoaders(loaderEntries).then(function (initialData) {\n      // On multiple pending navigations, only update interface with last\n      // in case they resolve out of order\n      if (currentIteration === _this3._loaderIteration) {\n        _this3.setState({\n          initialData: initialData,\n          match: match\n        });\n      }\n    });\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unlisten();\n  };\n  _proto.render = function render(props) {\n    return props.children;\n  };\n  return Router;\n}(Component);\n\nvar _excluded$5 = [\"basename\", \"context\", \"location\"];\nfunction _objectWithoutPropertiesLoose$5(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$6(subClass, superClass); }\nfunction _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n}\n// tslint:disable-next-line:no-empty\nvar noop = function noop() {};\nvar StaticRouter = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$6(StaticRouter, _Component);\n  function StaticRouter() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n    _this.createHref = function (path) {\n      return addLeadingSlash((_this.props.basename || '') + createURL(path));\n    };\n    _this.handlePush = function (location) {\n      var _this$props = _this.props,\n        basename = _this$props.basename,\n        context = _this$props.context;\n      context.action = 'PUSH';\n      context.location = addBasename(basename, isString(location) ? parsePath(location) : location);\n      context.url = createURL(context.location);\n    };\n    _this.handleReplace = function (location) {\n      var _this$props2 = _this.props,\n        basename = _this$props2.basename,\n        context = _this$props2.context;\n      context.action = 'REPLACE';\n      context.location = addBasename(basename, isString(location) ? parsePath(location) : location);\n      context.url = createURL(context.location);\n    };\n    // tslint:disable-next-line:no-empty\n    _this.handleListen = function () {\n      return noop;\n    };\n    // tslint:disable-next-line:no-empty\n    _this.handleBlock = function () {\n      return noop;\n    };\n    return _this;\n  }\n  var _proto = StaticRouter.prototype;\n  _proto.getChildContext = function getChildContext() {\n    return {\n      router: {\n        initialData: this.props.initialData,\n        staticContext: this.props.context\n      }\n    };\n  };\n  _proto.render = function render(_ref) {\n    var basename = _ref.basename;\n      _ref.context;\n      var location = _ref.location,\n      props = _objectWithoutPropertiesLoose$5(_ref, _excluded$5);\n    return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Router, combineFrom(props, {\n      history: {\n        action: 'POP',\n        block: this.handleBlock,\n        createHref: this.createHref,\n        go: staticHandler('go'),\n        goBack: staticHandler('goBack'),\n        goForward: staticHandler('goForward'),\n        listen: this.handleListen,\n        location: stripBasename(basename, createLocation(location)),\n        push: this.handlePush,\n        replace: this.handleReplace\n      }\n    }));\n  };\n  return StaticRouter;\n}(Component);\nStaticRouter.defaultProps = {\n  basename: '',\n  location: '/'\n};\nfunction normalizeLocation(_ref2) {\n  var _ref2$pathname = _ref2.pathname,\n    pathname = _ref2$pathname === void 0 ? '/' : _ref2$pathname,\n    search = _ref2.search,\n    hash = _ref2.hash;\n  return {\n    hash: (hash || '') === '#' ? '' : hash,\n    pathname: pathname,\n    search: (search || '') === '?' ? '' : search\n  };\n}\nfunction addBasename(basename, location) {\n  if (!basename) {\n    return location;\n  }\n  return combineFrom(location, {\n    pathname: addLeadingSlash(basename) + location.pathname\n  });\n}\nfunction stripBasename(basename, location) {\n  if (!basename) {\n    return location;\n  }\n  var base = addLeadingSlash(basename);\n  if (location.pathname.indexOf(base) !== 0) {\n    return location;\n  }\n  return combineFrom(location, {\n    pathname: location.pathname.substring(base.length)\n  });\n}\nfunction createLocation(location) {\n  return typeof location === 'string' ? parsePath(location) : normalizeLocation(location);\n}\nfunction createURL(location) {\n  return typeof location === 'string' ? location : combinePath(location);\n}\nfunction staticHandler(methodName) {\n  return function () {\n    invariant(false, 'You cannot %s with <StaticRouter>', methodName);\n  };\n}\n\nfunction _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$5(subClass, superClass); }\nfunction _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }\nvar BrowserRouter = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$5(BrowserRouter, _Component);\n  function BrowserRouter(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    _this.history = void 0;\n    _this.history = createBrowserHistory();\n    return _this;\n  }\n  var _proto = BrowserRouter.prototype;\n  _proto.render = function render() {\n    return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Router, {\n      children: this.props.children,\n      history: this.history,\n      initialData: this.props.initialData\n    });\n  };\n  return BrowserRouter;\n}(Component);\n\nfunction _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$4(subClass, superClass); }\nfunction _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }\nvar HashRouter = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$4(HashRouter, _Component);\n  function HashRouter(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    _this.history = void 0;\n    _this.history = createHashHistory();\n    return _this;\n  }\n  var _proto = HashRouter.prototype;\n  _proto.render = function render() {\n    return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Router, {\n      children: this.props.children,\n      history: this.history\n    });\n  };\n  return HashRouter;\n}(Component);\n\nfunction _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$3(subClass, superClass); }\nfunction _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }\nvar MemoryRouter = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$3(MemoryRouter, _Component);\n  function MemoryRouter(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    _this.history = void 0;\n    _this.history = createMemoryHistory(props);\n    return _this;\n  }\n  var _proto = MemoryRouter.prototype;\n  _proto.render = function render() {\n    return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Router, {\n      children: this.props.children,\n      history: this.history,\n      initialData: this.props.initialData\n    });\n  };\n  return MemoryRouter;\n}(Component);\n\nvar _excluded$4 = [\"computedMatch\"];\nfunction _objectWithoutPropertiesLoose$4(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$2(subClass, superClass); }\nfunction _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }\nvar Route = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$2(Route, _Component);\n  function Route(props, context) {\n    var _this;\n    _this = _Component.call(this, props, context) || this;\n    var match = _this.computeMatch(props, context.router);\n    _this.state = {\n      __loaderData__: match == null ? void 0 : match.loaderData,\n      match: match\n    };\n    return _this;\n  }\n  var _proto = Route.prototype;\n  _proto.getChildContext = function getChildContext() {\n    var parentRouter = this.context.router;\n    var router = combineFrom(parentRouter, null);\n    router.route = {\n      location: this.props.location || parentRouter.route.location,\n      match: this.state.match\n    };\n    return {\n      router: router\n    };\n  };\n  _proto.computeMatch = function computeMatch(_ref, router) {\n    var computedMatch = _ref.computedMatch,\n      props = _objectWithoutPropertiesLoose$4(_ref, _excluded$4);\n    if (!isNullOrUndef(computedMatch)) {\n      // <Switch> already computed the match for us\n      return computedMatch;\n    }\n    var path = props.path,\n      strict = props.strict,\n      exact = props.exact,\n      sensitive = props.sensitive,\n      loader = props.loader;\n    var route = router.route,\n      initialData = router.initialData; // This is the parent route\n    var pathname = (props.location || route.location).pathname;\n    return path ? matchPath(pathname, {\n      path: path,\n      strict: strict,\n      exact: exact,\n      sensitive: sensitive,\n      loader: loader,\n      initialData: initialData\n    }) : route.match;\n  };\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    var match = this.computeMatch(nextProps, nextContext.router);\n    this.setState({\n      __loaderData__: match == null ? void 0 : match.loaderData,\n      match: match\n    });\n  };\n  _proto.render = function render(props, state, context) {\n    var match = state.match,\n      __loaderData__ = state.__loaderData__;\n    var children = props.children,\n      component = props.component,\n      render = props.render,\n      loader = props.loader;\n    var _context$router = context.router,\n      history = _context$router.history,\n      route = _context$router.route,\n      staticContext = _context$router.staticContext;\n    var location = props.location || route.location;\n    var renderProps = {\n      match: match,\n      location: location,\n      history: history,\n      staticContext: staticContext,\n      component: component,\n      render: render,\n      loader: loader,\n      __loaderData__: __loaderData__\n    };\n    // If we have a loader we don't render until it has been resolved\n    if (!isUndefined(loader) && isUndefined(__loaderData__)) {\n      return null;\n    }\n    if (component) {\n      return match ? createComponentVNode(2 /* VNodeFlags.ComponentUnknown */, component, renderProps) : null;\n    }\n    if (render) {\n      // @ts-ignore\n      return match ? render(renderProps, this.context) : null;\n    }\n    if (typeof children === 'function') {\n      return children(renderProps);\n    }\n    return children;\n  };\n  return Route;\n}(Component);\n\nvar _excluded$3 = [\"key\", \"state\"];\nfunction _objectWithoutPropertiesLoose$3(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nvar normalizeToLocation = function normalizeToLocation(to) {\n  return isString(to) ? parsePath(to) : to;\n};\nvar splitLocation = function splitLocation(location) {\n  location.key;\n    var state = location.state,\n    to = _objectWithoutPropertiesLoose$3(location, _excluded$3);\n  return {\n    to: to,\n    state: state\n  };\n};\n\nvar _excluded$2 = [\"replace\", \"children\", \"className\", \"to\", \"innerRef\"];\nfunction _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return Boolean(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\nfunction handleClick(_ref, event) {\n  var props = _ref.props,\n    context = _ref.context;\n  if (props.onClick) {\n    props.onClick(event);\n  }\n  if (!event.defaultPrevented &&\n  // onClick prevented default\n  event.button === 0 &&\n  // ignore everything but left clicks\n  !props.target &&\n  // let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // ignore clicks with modifier keys\n  ) {\n    event.preventDefault();\n    var history = context.router.history;\n    var _props$replace = props.replace,\n      replace = _props$replace === void 0 ? false : _props$replace,\n      toPropIn = props.to;\n    var _splitLocation = splitLocation(normalizeToLocation(toPropIn)),\n      to = _splitLocation.to,\n      state = _splitLocation.state;\n    if (replace) {\n      history.replace(to, state);\n    } else {\n      history.push(to, state);\n    }\n  }\n}\n/**\n * The public API for rendering a history-aware <a>.\n */\nfunction Link(props, context) {\n  props.replace;\n    var children = props.children,\n    className = props.className,\n    _props$to = props.to,\n    to = _props$to === void 0 ? '' : _props$to,\n    innerRef = props.innerRef,\n    rest = _objectWithoutPropertiesLoose$2(props, _excluded$2);\n  invariant(context.router, 'You should not use <Link> outside a <Router>');\n  var href = context.router.history.createHref(isString(to) ? parsePath(to) : to);\n  var newProps = combineFrom(rest, null);\n  newProps.href = href;\n  newProps.onClick = linkEvent({\n    context: context,\n    props: props\n  }, handleClick);\n  return createVNode(1 /* VNodeFlags.HtmlElement */, 'a', className, children, 0 /* ChildFlags.UnknownChildren */, newProps, null, innerRef);\n}\n\nvar _excluded$1 = [\"to\", \"exact\", \"strict\", \"onClick\", \"location\", \"activeClassName\", \"className\", \"activeStyle\", \"style\", \"isActive\", \"ariaCurrent\"];\nfunction _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction filter(i) {\n  return i;\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nfunction NavLink(_ref) {\n  var to = _ref.to,\n    exact = _ref.exact,\n    strict = _ref.strict,\n    onClick = _ref.onClick,\n    linkLocation = _ref.location,\n    _ref$activeClassName = _ref.activeClassName,\n    activeClassName = _ref$activeClassName === void 0 ? 'active' : _ref$activeClassName,\n    classNameProp = _ref.className,\n    activeStyle = _ref.activeStyle,\n    styleProp = _ref.style,\n    getIsActive = _ref.isActive,\n    _ref$ariaCurrent = _ref.ariaCurrent,\n    ariaCurrent = _ref$ariaCurrent === void 0 ? 'true' : _ref$ariaCurrent,\n    rest = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);\n  function linkComponent(_ref2) {\n    var location = _ref2.location,\n      match = _ref2.match;\n    var isActive = Boolean(getIsActive ? getIsActive(match, location) : match);\n    var className = typeof classNameProp === 'function' ? classNameProp(isActive) : classNameProp;\n    var style = typeof styleProp === 'function' ? styleProp(isActive) : styleProp;\n    return createComponentVNode(8 /* VNodeFlags.ComponentFunction */, Link, combineFrom({\n      'aria-current': isActive && ariaCurrent || null,\n      className: isActive ? [className, activeClassName].filter(filter).join(' ') : className,\n      onClick: onClick,\n      style: isActive ? combineFrom(style, activeStyle) : style,\n      to: to\n    }, rest));\n  }\n  return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Route, {\n    children: linkComponent,\n    exact: exact,\n    location: linkLocation,\n    path: typeof to === 'object' ? to.pathname : to,\n    strict: strict\n  });\n}\n\nfunction _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$1(subClass, superClass); }\nfunction _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }\n/**\n * The public API for matching a single path and rendering.\n */\nvar Prompt = /*#__PURE__*/function (_Component) {\n  _inheritsLoose$1(Prompt, _Component);\n  function Prompt() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n    _this.unblock = void 0;\n    return _this;\n  }\n  var _proto = Prompt.prototype;\n  _proto.enable = function enable(message) {\n    var _this2 = this;\n    if (this.unblock) {\n      this.unblock();\n    }\n    this.unblock = this.context.router.history.block(function (tx) {\n      if (message && window.confirm(message)) {\n        _this2.unblock();\n        tx.retry();\n      }\n    });\n  };\n  _proto.disable = function disable() {\n    if (this.unblock) {\n      this.unblock();\n      this.unblock = null;\n    }\n  };\n  _proto.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, 'You should not use <Prompt> outside a <Router>');\n    if (this.props.when) {\n      this.enable(this.props.message);\n    }\n  };\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (nextProps.when) {\n      if (!this.props.when || this.props.message !== nextProps.message) {\n        this.enable(nextProps.message);\n      }\n    } else {\n      this.disable();\n    }\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.disable();\n  };\n  _proto.render = function render() {\n    return null;\n  };\n  return Prompt;\n}(Component);\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction getLocationTarget(to) {\n  if (!isString(to)) {\n    to = combinePath(to);\n  }\n  return parsePath(to);\n}\nvar Redirect = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Redirect, _Component);\n  function Redirect() {\n    return _Component.apply(this, arguments) || this;\n  }\n  var _proto = Redirect.prototype;\n  _proto.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n  _proto.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, 'You should not use <Redirect> outside a <Router>');\n    if (this.isStatic()) {\n      this.perform();\n    }\n  };\n  _proto.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) {\n      this.perform();\n    }\n  };\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = getLocationTarget(prevProps.to);\n    var nextTo = getLocationTarget(this.props.to);\n    if (prevTo.pathname === nextTo.pathname && prevTo.search === nextTo.search) {\n      // tslint:disable-next-line:no-console\n      console.error(\"You tried to redirect to the same route you're currently on: \\\"\" + nextTo.pathname + nextTo.search + \"\\\"\");\n      return;\n    }\n    this.perform();\n  };\n  _proto.perform = function perform() {\n    var history = this.context.router.history;\n    var _this$props = this.props,\n      _this$props$push = _this$props.push,\n      push = _this$props$push === void 0 ? false : _this$props$push,\n      to = _this$props.to;\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n  _proto.render = function render() {\n    return null;\n  };\n  return Redirect;\n}(Component);\n\nvar _excluded = [\"wrappedComponentRef\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/**\n * A public higher-order component to access the imperative API\n */\nfunction withRouter(Com) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n      remainingProps = _objectWithoutPropertiesLoose(props, _excluded);\n    return createComponentVNode(4 /* VNodeFlags.ComponentClass */, Route, {\n      render: function render(routeComponentProps) {\n        return createComponentVNode(2 /* VNodeFlags.ComponentUnknown */, Com, combineFrom(remainingProps, routeComponentProps), null, wrappedComponentRef);\n      }\n    });\n  };\n  C.displayName = \"withRouter(\" + (Com.displayName || Com.name) + \")\";\n  C.WrappedComponent = Com;\n  return hoistNonReactStatics(C, Com);\n}\n\nfunction useLoaderData(props) {\n  var _props$__loaderData__;\n  return (_props$__loaderData__ = props.__loaderData__) == null ? void 0 : _props$__loaderData__.res;\n}\nfunction useLoaderError(props) {\n  var _props$__loaderData__2;\n  return (_props$__loaderData__2 = props.__loaderData__) == null ? void 0 : _props$__loaderData__2.err;\n}\n\nexport { BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Redirect, Route, Router, StaticRouter, Switch, createClientSideURL, matchPath, resolveLoaders, traverseLoaders, useLoaderData, useLoaderError, withRouter };\n","var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n  var type = typeof o;\n  return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n  return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n  return typeof o === 'function';\n}\nfunction isString(o) {\n  return typeof o === 'string';\n}\nfunction isNumber(o) {\n  return typeof o === 'number';\n}\nfunction isNull(o) {\n  return o === null;\n}\nfunction isUndefined(o) {\n  return o === void 0;\n}\nfunction combineFrom(first, second) {\n  var out = {};\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n  if (second) {\n    for (var _key in second) {\n      out[_key] = second[_key];\n    }\n  }\n  return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n  if (isFunction(event)) {\n    return {\n      data: data,\n      event: event\n    };\n  }\n  return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n  return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// It's used for comparison, so we can't inline it into shared\nvar EMPTY_OBJ = {};\n// @ts-ignore\nvar Fragment = '$F';\nvar AnimationQueues = function AnimationQueues() {\n  this.componentDidAppear = [];\n  this.componentWillDisappear = [];\n  this.componentWillMove = [];\n};\nfunction normalizeEventName(name) {\n  return name.substring(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n  parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n  if (isNull(nextNode)) {\n    appendChild(parentDOM, newNode);\n  } else {\n    parentDOM.insertBefore(newNode, nextNode);\n  }\n}\nfunction documentCreateElement(tag, isSVG) {\n  if (isSVG) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n  }\n  return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n  parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n  parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n  for (var i = 0; i < arrayFn.length; i++) {\n    arrayFn[i]();\n  }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n  var children = vNode.children;\n  if (flags & 4 /* VNodeFlags.ComponentClass */) {\n    return children.$LI;\n  }\n  if (flags & 8192 /* VNodeFlags.Fragment */) {\n    return vNode.childFlags === 2 /* ChildFlags.HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n  }\n  return children;\n}\nfunction findDOMFromVNode(vNode, startEdge) {\n  var flags;\n  while (vNode) {\n    flags = vNode.flags;\n    if (flags & 1521 /* VNodeFlags.DOMRef */) {\n      return vNode.dom;\n    }\n    vNode = findChildVNode(vNode, startEdge, flags);\n  }\n  return null;\n}\nfunction callAllAnimationHooks(animationQueue, callback) {\n  var animationsLeft = animationQueue.length;\n  // Picking from the top because it is faster, invocation order should be irrelevant\n  // since all animations are to be run and we can't predict the order in which they complete.\n  var fn;\n  while ((fn = animationQueue.pop()) !== undefined) {\n    fn(function () {\n      if (--animationsLeft <= 0 && isFunction(callback)) {\n        callback();\n      }\n    });\n  }\n}\nfunction callAllMoveAnimationHooks(animationQueue) {\n  // Start the animations.\n  for (var i = 0; i < animationQueue.length; i++) {\n    animationQueue[i].fn();\n  }\n  // Perform the actual DOM moves when all measurements of initial\n  // position have been performed. The rest of the animations are done\n  // async.\n  for (var _i = 0; _i < animationQueue.length; _i++) {\n    var tmp = animationQueue[_i];\n    insertOrAppend(tmp.parent, tmp.dom, tmp.next);\n  }\n  animationQueue.splice(0, animationQueue.length);\n}\nfunction clearVNodeDOM(vNode, parentDOM, deferredRemoval) {\n  do {\n    var flags = vNode.flags;\n    if (flags & 1521 /* VNodeFlags.DOMRef */) {\n      // On deferred removals the node might disappear because of later operations\n      if (!deferredRemoval || vNode.dom.parentNode === parentDOM) {\n        removeChild(parentDOM, vNode.dom);\n      }\n      return;\n    }\n    var children = vNode.children;\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      vNode = children.$LI;\n    }\n    if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      vNode = children;\n    }\n    if (flags & 8192 /* VNodeFlags.Fragment */) {\n      if (vNode.childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          clearVNodeDOM(children[i], parentDOM, false);\n        }\n        return;\n      }\n    }\n  } while (vNode);\n}\nfunction createDeferComponentClassRemovalCallback(vNode, parentDOM) {\n  return function () {\n    // Mark removal as deferred to trigger check that node still exists\n    clearVNodeDOM(vNode, parentDOM, true);\n  };\n}\nfunction removeVNodeDOM(vNode, parentDOM, animations) {\n  if (animations.componentWillDisappear.length > 0) {\n    // Wait until animations are finished before removing actual dom nodes\n    callAllAnimationHooks(animations.componentWillDisappear, createDeferComponentClassRemovalCallback(vNode, parentDOM));\n  } else {\n    clearVNodeDOM(vNode, parentDOM, false);\n  }\n}\nfunction addMoveAnimationHook(animations, parentVNode, refOrInstance, dom, parentDOM, nextNode, flags, props) {\n  animations.componentWillMove.push({\n    dom: dom,\n    fn: function fn() {\n      if (flags & 4 /* VNodeFlags.ComponentClass */) {\n        refOrInstance.componentWillMove(parentVNode, parentDOM, dom);\n      } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n        refOrInstance.onComponentWillMove(parentVNode, parentDOM, dom, props);\n      }\n    },\n    next: nextNode,\n    parent: parentDOM\n  });\n}\nfunction moveVNodeDOM(parentVNode, vNode, parentDOM, nextNode, animations) {\n  var refOrInstance;\n  var instanceProps;\n  var instanceFlags = vNode.flags;\n  do {\n    var flags = vNode.flags;\n    if (flags & 1521 /* VNodeFlags.DOMRef */) {\n      if (!isNullOrUndef(refOrInstance) && (isFunction(refOrInstance.componentWillMove) || isFunction(refOrInstance.onComponentWillMove))) {\n        addMoveAnimationHook(animations, parentVNode, refOrInstance, vNode.dom, parentDOM, nextNode, instanceFlags, instanceProps);\n      } else {\n        // TODO: Should we delay this too to support mixing animated moves with regular?\n        insertOrAppend(parentDOM, vNode.dom, nextNode);\n      }\n      return;\n    }\n    var children = vNode.children;\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      refOrInstance = vNode.children;\n      // TODO: We should probably deprecate this in V9 since it is inconsitent with other class component hooks\n      instanceProps = vNode.props;\n      vNode = children.$LI;\n    } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      refOrInstance = vNode.ref;\n      instanceProps = vNode.props;\n      vNode = children;\n    } else if (flags & 8192 /* VNodeFlags.Fragment */) {\n      if (vNode.childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          moveVNodeDOM(parentVNode, children[i], parentDOM, nextNode, animations);\n        }\n        return;\n      }\n    }\n  } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n  if (instance.constructor.getDerivedStateFromProps) {\n    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n  }\n  return state;\n}\nvar renderCheck = {\n  v: false\n};\nvar options = {\n  componentComparator: null,\n  createVNode: null,\n  renderComplete: null\n};\nfunction setTextContent(dom, children) {\n  dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;\n}\nfunction mergeUnsetProperties(to, from) {\n  for (var propName in from) {\n    if (isUndefined(to[propName])) {\n      to[propName] = from[propName];\n    }\n  }\n  return to;\n}\nfunction safeCall1(method, arg1) {\n  return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n  this.childFlags = childFlags;\n  this.children = children;\n  this.className = className;\n  this.dom = null;\n  this.flags = flags;\n  this.key = key === void 0 ? null : key;\n  this.props = props === void 0 ? null : props;\n  this.ref = ref === void 0 ? null : ref;\n  this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n  var childFlag = childFlags === void 0 ? 1 /* ChildFlags.HasInvalidChildren */ : childFlags;\n  var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n  if (childFlag === 0 /* ChildFlags.UnknownChildren */) {\n    normalizeChildren(vNode, vNode.children);\n  }\n  return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n  if (flags & 4 /* VNodeFlags.ComponentClass */) {\n    return ref;\n  }\n  var defaultHooks = (flags & 32768 /* VNodeFlags.ForwardRef */ ? type.render : type).defaultHooks;\n  if (isNullOrUndef(defaultHooks)) {\n    return ref;\n  }\n  if (isNullOrUndef(ref)) {\n    return defaultHooks;\n  }\n  return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n  // set default props\n  var defaultProps = (flags & 32768 /* VNodeFlags.ForwardRef */ ? type.render : type).defaultProps;\n  if (isNullOrUndef(defaultProps)) {\n    return props;\n  }\n  if (isNullOrUndef(props)) {\n    return combineFrom(defaultProps, null);\n  }\n  return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n  if (flags & 12 /* VNodeFlags.ComponentKnown */) {\n    return flags;\n  }\n  if (type.prototype && type.prototype.render) {\n    return 4 /* VNodeFlags.ComponentClass */;\n  }\n\n  if (type.render) {\n    return 32776 /* VNodeFlags.ForwardRefComponent */;\n  }\n\n  return 8 /* VNodeFlags.ComponentFunction */;\n}\n\nfunction createComponentVNode(flags, type, props, key, ref) {\n  flags = resolveComponentFlags(flags, type);\n  var vNode = new V(1 /* ChildFlags.HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n  return vNode;\n}\nfunction createTextVNode(text, key) {\n  return new V(1 /* ChildFlags.HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* VNodeFlags.Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n  var fragment = createVNode(8192 /* VNodeFlags.Fragment */, 8192 /* VNodeFlags.Fragment */, null, children, childFlags, null, key, null);\n  switch (fragment.childFlags) {\n    case 1 /* ChildFlags.HasInvalidChildren */:\n      fragment.children = createVoidVNode();\n      fragment.childFlags = 2 /* ChildFlags.HasVNodeChildren */;\n      break;\n    case 16 /* ChildFlags.HasTextChildren */:\n      fragment.children = [createTextVNode(children)];\n      fragment.childFlags = 4 /* ChildFlags.HasNonKeyedChildren */;\n      break;\n  }\n  return fragment;\n}\nfunction normalizeProps(vNode) {\n  var props = vNode.props;\n  if (props) {\n    var flags = vNode.flags;\n    if (flags & 481 /* VNodeFlags.Element */) {\n      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n        normalizeChildren(vNode, props.children);\n      }\n      if (props.className !== void 0) {\n        if (isNullOrUndef(vNode.className)) {\n          vNode.className = props.className || null;\n        }\n        props.className = undefined;\n      }\n    }\n    if (props.key !== void 0) {\n      vNode.key = props.key;\n      props.key = undefined;\n    }\n    if (props.ref !== void 0) {\n      if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n        vNode.ref = combineFrom(vNode.ref, props.ref);\n      } else {\n        vNode.ref = props.ref;\n      }\n      props.ref = undefined;\n    }\n  }\n  return vNode;\n}\n/*\n * Fragment is different from normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n  var oldChildren = vNodeToClone.children;\n  var childFlags = vNodeToClone.childFlags;\n  return createFragment(childFlags === 2 /* ChildFlags.HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n  var flags = vNodeToClone.flags & -16385 /* VNodeFlags.ClearInUse */;\n  var props = vNodeToClone.props;\n  if (flags & 14 /* VNodeFlags.Component */) {\n    if (!isNull(props)) {\n      var propsToClone = props;\n      props = {};\n      for (var key in propsToClone) {\n        props[key] = propsToClone[key];\n      }\n    }\n  }\n  if ((flags & 8192 /* VNodeFlags.Fragment */) === 0) {\n    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n  }\n  return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n  return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n  var normalizedRoot = normalizeRoot(children);\n  return createVNode(1024 /* VNodeFlags.Portal */, 1024 /* VNodeFlags.Portal */, null, normalizedRoot, 0 /* ChildFlags.UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n  for (var len = nodes.length; index < len; index++) {\n    var n = nodes[index];\n    if (!isInvalid(n)) {\n      var newKey = currentKey + keyPrefix + index;\n      if (isArray(n)) {\n        _normalizeVNodes(n, result, 0, newKey);\n      } else {\n        if (isStringOrNumber(n)) {\n          n = createTextVNode(n, newKey);\n        } else {\n          var oldKey = n.key;\n          var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n          if (n.flags & 81920 /* VNodeFlags.InUseOrNormalized */ || isPrefixedKey) {\n            n = directClone(n);\n          }\n          n.flags |= 65536 /* VNodeFlags.Normalized */;\n          if (!isPrefixedKey) {\n            if (isNull(oldKey)) {\n              n.key = newKey;\n            } else {\n              n.key = currentKey + oldKey;\n            }\n          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n            n.key = currentKey + oldKey;\n          }\n        }\n        result.push(n);\n      }\n    }\n  }\n}\nfunction getFlagsForElementVnode(type) {\n  switch (type) {\n    case 'svg':\n      return 32 /* VNodeFlags.SvgElement */;\n    case 'input':\n      return 64 /* VNodeFlags.InputElement */;\n    case 'select':\n      return 256 /* VNodeFlags.SelectElement */;\n    case 'textarea':\n      return 128 /* VNodeFlags.TextareaElement */;\n    // @ts-ignore\n    case Fragment:\n      return 8192 /* VNodeFlags.Fragment */;\n    default:\n      return 1 /* VNodeFlags.HtmlElement */;\n  }\n}\n\nfunction normalizeChildren(vNode, children) {\n  var newChildren;\n  var newChildFlags = 1 /* ChildFlags.HasInvalidChildren */;\n  // Don't change children to match strict equal (===) true in patching\n  if (isInvalid(children)) {\n    newChildren = children;\n  } else if (isStringOrNumber(children)) {\n    newChildFlags = 16 /* ChildFlags.HasTextChildren */;\n    newChildren = children;\n  } else if (isArray(children)) {\n    var len = children.length;\n    for (var i = 0; i < len; ++i) {\n      var n = children[i];\n      if (isInvalid(n) || isArray(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        _normalizeVNodes(children, newChildren, i, '');\n        break;\n      } else if (isStringOrNumber(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        newChildren.push(createTextVNode(n, keyPrefix + i));\n      } else {\n        var key = n.key;\n        var needsCloning = (n.flags & 81920 /* VNodeFlags.InUseOrNormalized */) > 0;\n        var isNullKey = isNull(key);\n        var isPrefixed = isString(key) && key[0] === keyPrefix;\n        if (needsCloning || isNullKey || isPrefixed) {\n          newChildren = newChildren || children.slice(0, i);\n          if (needsCloning || isPrefixed) {\n            n = directClone(n);\n          }\n          if (isNullKey || isPrefixed) {\n            n.key = keyPrefix + i;\n          }\n          newChildren.push(n);\n        } else if (newChildren) {\n          newChildren.push(n);\n        }\n        n.flags |= 65536 /* VNodeFlags.Normalized */;\n      }\n    }\n\n    newChildren = newChildren || children;\n    if (newChildren.length === 0) {\n      newChildFlags = 1 /* ChildFlags.HasInvalidChildren */;\n    } else {\n      newChildFlags = 8 /* ChildFlags.HasKeyedChildren */;\n    }\n  } else {\n    newChildren = children;\n    newChildren.flags |= 65536 /* VNodeFlags.Normalized */;\n    if (children.flags & 81920 /* VNodeFlags.InUseOrNormalized */) {\n      newChildren = directClone(children);\n    }\n    newChildFlags = 2 /* ChildFlags.HasVNodeChildren */;\n  }\n\n  vNode.children = newChildren;\n  vNode.childFlags = newChildFlags;\n  return vNode;\n}\nfunction normalizeRoot(input) {\n  if (isInvalid(input) || isStringOrNumber(input)) {\n    return createTextVNode(input, null);\n  }\n  if (isArray(input)) {\n    return createFragment(input, 0 /* ChildFlags.UnknownChildren */, null);\n  }\n  return input.flags & 16384 /* VNodeFlags.InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n  'xlink:actuate': xlinkNS,\n  'xlink:arcrole': xlinkNS,\n  'xlink:href': xlinkNS,\n  'xlink:role': xlinkNS,\n  'xlink:show': xlinkNS,\n  'xlink:title': xlinkNS,\n  'xlink:type': xlinkNS,\n  'xml:base': xmlNS,\n  'xml:lang': xmlNS,\n  'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n  return {\n    onClick: v,\n    onDblClick: v,\n    onFocusIn: v,\n    onFocusOut: v,\n    onKeyDown: v,\n    onKeyPress: v,\n    onKeyUp: v,\n    onMouseDown: v,\n    onMouseMove: v,\n    onMouseUp: v,\n    onTouchEnd: v,\n    onTouchMove: v,\n    onTouchStart: v\n  };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n  if (!eventsObject) {\n    eventsObject = dom.$EV = getDelegatedEventObject(null);\n  }\n  if (!eventsObject[name]) {\n    if (++attachedEventCounts[name] === 1) {\n      attachedEvents[name] = attachEventToDocument(name);\n    }\n  }\n  return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n  if (eventsObject && eventsObject[name]) {\n    if (--attachedEventCounts[name] === 0) {\n      document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n      attachedEvents[name] = null;\n    }\n    eventsObject[name] = null;\n  }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n  if (isFunction(nextEvent)) {\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else if (isLinkEventObject(nextEvent)) {\n    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n      return;\n    }\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else {\n    unmountSyntheticEvent(name, dom);\n  }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n  return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n  var dom = getTargetNode(event);\n  do {\n    // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n    // because the event listener is on document.body\n    // Don't process clicks on disabled elements\n    if (isClick && dom.disabled) {\n      return;\n    }\n    var eventsObject = dom.$EV;\n    if (eventsObject) {\n      var currentEvent = eventsObject[name];\n      if (currentEvent) {\n        // linkEvent object\n        eventData.dom = dom;\n        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n        if (event.cancelBubble) {\n          return;\n        }\n      }\n    }\n    dom = dom.parentNode;\n  } while (!isNull(dom));\n}\nfunction stopPropagation() {\n  this.cancelBubble = true;\n  if (!this.immediatePropagationStopped) {\n    this.stopImmediatePropagation();\n  }\n}\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n  // Event data needs to be object to save reference to currentTarget getter\n  var eventData = {\n    dom: document\n  };\n  event.isDefaultPrevented = isDefaultPrevented;\n  event.isPropagationStopped = isPropagationStopped;\n  event.stopPropagation = stopPropagation;\n  Object.defineProperty(event, 'currentTarget', {\n    configurable: true,\n    get: function get() {\n      return eventData.dom;\n    }\n  });\n  return eventData;\n}\nfunction rootClickEvent(name) {\n  return function (event) {\n    if (event.button !== 0) {\n      // Firefox incorrectly triggers click event for mid/right mouse buttons.\n      // This bug has been active for 17 years.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n      event.stopPropagation();\n      return;\n    }\n    dispatchEvents(event, true, name, extendEventProperties(event));\n  };\n}\nfunction rootEvent(name) {\n  return function (event) {\n    dispatchEvents(event, false, name, extendEventProperties(event));\n  };\n}\nfunction attachEventToDocument(name) {\n  var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n  document.addEventListener(normalizeEventName(name), attachedEvent);\n  return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n  var tempdom = document.createElement('i');\n  tempdom.innerHTML = innerHTML;\n  return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n  if (props[methodName]) {\n    var listener = props[methodName];\n    if (listener.event) {\n      listener.event(listener.data, e);\n    } else {\n      listener(e);\n    }\n  } else {\n    var nativeListenerName = methodName.toLowerCase();\n    if (props[nativeListenerName]) {\n      props[nativeListenerName](e);\n    }\n  }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n  var fnMethod = function fnMethod(e) {\n    var vNode = this.$V;\n    // If vNode is gone by the time event fires, no-op\n    if (!vNode) {\n      return;\n    }\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (isString(methodName)) {\n      triggerEventListener(props, methodName, e);\n    } else {\n      for (var i = 0; i < methodName.length; ++i) {\n        triggerEventListener(props, methodName[i], e);\n      }\n    }\n    if (isFunction(applyValue)) {\n      var newVNode = this.$V;\n      var newProps = newVNode.props || EMPTY_OBJ;\n      applyValue(newProps, dom, false, newVNode);\n    }\n  };\n  Object.defineProperty(fnMethod, 'wrapped', {\n    configurable: false,\n    enumerable: false,\n    value: true,\n    writable: false\n  });\n  return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n  var previousKey = \"$\" + eventName;\n  var previousArgs = dom[previousKey];\n  if (previousArgs) {\n    if (previousArgs[1].wrapped) {\n      return;\n    }\n    dom.removeEventListener(previousArgs[0], previousArgs[1]);\n    dom[previousKey] = null;\n  }\n  if (isFunction(handler)) {\n    dom.addEventListener(eventName, handler);\n    dom[previousKey] = [eventName, handler];\n  }\n}\n\nfunction isCheckedType(type) {\n  return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange$1 = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n  event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n  if (isCheckedType(nextPropsOrEmpty.type)) {\n    attachEvent(dom, 'change', wrappedOnChange$1);\n    attachEvent(dom, 'click', emptywrapper);\n  } else {\n    attachEvent(dom, 'input', onTextInputChange);\n  }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n  var type = nextPropsOrEmpty.type;\n  var value = nextPropsOrEmpty.value;\n  var checked = nextPropsOrEmpty.checked;\n  var multiple = nextPropsOrEmpty.multiple;\n  var defaultValue = nextPropsOrEmpty.defaultValue;\n  var hasValue = !isNullOrUndef(value);\n  if (type && type !== dom.type) {\n    dom.setAttribute('type', type);\n  }\n  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n    dom.multiple = multiple;\n  }\n  if (!isNullOrUndef(defaultValue) && !hasValue) {\n    dom.defaultValue = defaultValue + '';\n  }\n  if (isCheckedType(type)) {\n    if (hasValue) {\n      dom.value = value;\n    }\n    if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  } else {\n    if (hasValue && dom.value !== value) {\n      dom.defaultValue = value;\n      dom.value = value;\n    } else if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  }\n}\n\nfunction updateChildOptions(vNode, value) {\n  if (vNode.type === 'option') {\n    updateChildOption(vNode, value);\n  } else {\n    var children = vNode.children;\n    var flags = vNode.flags;\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      updateChildOptions(children.$LI, value);\n    } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags & 12 /* ChildFlags.MultipleChildren */) {\n      for (var i = 0, len = children.length; i < len; ++i) {\n        updateChildOptions(children[i], value);\n      }\n    }\n  }\n}\nfunction updateChildOption(vNode, value) {\n  var props = vNode.props || EMPTY_OBJ;\n  var dom = vNode.dom;\n  // we do this as multiple may have changed\n  dom.value = props.value;\n  if (props.value === value || isArray(value) && value.indexOf(props.value) !== -1) {\n    dom.selected = true;\n  } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n    dom.selected = props.selected || false;\n  }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n  attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n    dom.multiple = multiplePropInBoolean;\n  }\n  var index = nextPropsOrEmpty.selectedIndex;\n  if (index === -1) {\n    dom.selectedIndex = -1;\n  }\n  var childFlags = vNode.childFlags;\n  if (childFlags !== 1 /* ChildFlags.HasInvalidChildren */) {\n    var value = nextPropsOrEmpty.value;\n    if (isNumber(index) && index > -1 && dom.options[index]) {\n      value = dom.options[index].value;\n    }\n    if (mounting && isNullOrUndef(value)) {\n      value = nextPropsOrEmpty.defaultValue;\n    }\n    updateChildOptions(vNode, value);\n  }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n  attachEvent(dom, 'input', onTextareaInputChange);\n  if (nextPropsOrEmpty.onChange) {\n    attachEvent(dom, 'change', wrappedOnChange);\n  }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n  var value = nextPropsOrEmpty.value;\n  var domValue = dom.value;\n  if (isNullOrUndef(value)) {\n    if (mounting) {\n      var defaultValue = nextPropsOrEmpty.defaultValue;\n      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n        dom.defaultValue = defaultValue;\n        dom.value = defaultValue;\n      }\n    }\n  } else if (domValue !== value) {\n    /* There is value so keep it controlled */\n    dom.defaultValue = value;\n    dom.value = value;\n  }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n  if (flags & 64 /* VNodeFlags.InputElement */) {\n    applyValueInput(nextPropsOrEmpty, dom);\n  } else if (flags & 256 /* VNodeFlags.SelectElement */) {\n    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n  } else if (flags & 128 /* VNodeFlags.TextareaElement */) {\n    applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n  }\n  if (isControlled) {\n    dom.$V = vNode;\n  }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n  if (flags & 64 /* VNodeFlags.InputElement */) {\n    inputEvents(dom, nextPropsOrEmpty);\n  } else if (flags & 256 /* VNodeFlags.SelectElement */) {\n    selectEvents(dom);\n  } else if (flags & 128 /* VNodeFlags.TextareaElement */) {\n    textAreaEvents(dom, nextPropsOrEmpty);\n  }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n  return {\n    current: null\n  };\n}\n// TODO: Make this return value typed\nfunction forwardRef(render) {\n  var ref = {\n    render: render\n  };\n  // @ts-ignore\n  return ref;\n}\nfunction unmountRef(ref) {\n  if (ref) {\n    if (!safeCall1(ref, null) && ref.current) {\n      ref.current = null;\n    }\n  }\n}\nfunction mountRef(ref, value, lifecycle) {\n  if (ref && (isFunction(ref) || ref.current !== void 0)) {\n    lifecycle.push(function () {\n      if (!safeCall1(ref, value) && ref.current !== void 0) {\n        ref.current = value;\n      }\n    });\n  }\n}\n\nfunction remove(vNode, parentDOM, animations) {\n  unmount(vNode, animations);\n  removeVNodeDOM(vNode, parentDOM, animations);\n}\nfunction unmount(vNode, animations) {\n  var flags = vNode.flags;\n  var children = vNode.children;\n  var ref;\n  if (flags & 481 /* VNodeFlags.Element */) {\n    ref = vNode.ref;\n    var props = vNode.props;\n    unmountRef(ref);\n    var childFlags = vNode.childFlags;\n    if (!isNull(props)) {\n      var keys = Object.keys(props);\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i];\n        if (syntheticEvents[key]) {\n          unmountSyntheticEvent(key, vNode.dom);\n        }\n      }\n    }\n    if (childFlags & 12 /* ChildFlags.MultipleChildren */) {\n      unmountAllChildren(children, animations);\n    } else if (childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n      unmount(children, animations);\n    }\n  } else if (children) {\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      if (isFunction(children.componentWillUnmount)) {\n        // TODO: Possible entrypoint\n        children.componentWillUnmount();\n      }\n      // If we have a componentWillDisappear on this component, block children from animating\n      var childAnimations = animations;\n      if (isFunction(children.componentWillDisappear)) {\n        childAnimations = new AnimationQueues();\n        addDisappearAnimationHook(animations, children, children.$LI.dom, flags, undefined);\n      }\n      unmountRef(vNode.ref);\n      children.$UN = true;\n      unmount(children.$LI, childAnimations);\n    } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      // If we have a onComponentWillDisappear on this component, block children from animating\n      var _childAnimations = animations;\n      ref = vNode.ref;\n      if (!isNullOrUndef(ref)) {\n        var domEl = null;\n        if (isFunction(ref.onComponentWillUnmount)) {\n          domEl = findDOMFromVNode(vNode, true);\n          ref.onComponentWillUnmount(domEl, vNode.props || EMPTY_OBJ);\n        }\n        if (isFunction(ref.onComponentWillDisappear)) {\n          _childAnimations = new AnimationQueues();\n          domEl = domEl || findDOMFromVNode(vNode, true);\n          addDisappearAnimationHook(animations, ref, domEl, flags, vNode.props);\n        }\n      }\n      unmount(children, _childAnimations);\n    } else if (flags & 1024 /* VNodeFlags.Portal */) {\n      remove(children, vNode.ref, animations);\n    } else if (flags & 8192 /* VNodeFlags.Fragment */) {\n      if (vNode.childFlags & 12 /* ChildFlags.MultipleChildren */) {\n        unmountAllChildren(children, animations);\n      }\n    }\n  }\n}\nfunction unmountAllChildren(children, animations) {\n  for (var i = 0, len = children.length; i < len; ++i) {\n    unmount(children[i], animations);\n  }\n}\nfunction createClearAllCallback(children, parentDOM) {\n  return function () {\n    // We need to remove children one by one because elements can be added during animation\n    if (parentDOM) {\n      for (var i = 0; i < children.length; i++) {\n        var vNode = children[i];\n        clearVNodeDOM(vNode, parentDOM, false);\n      }\n    }\n  };\n}\nfunction clearDOM(parentDOM, children, animations) {\n  if (animations.componentWillDisappear.length > 0) {\n    // Wait until animations are finished before removing actual dom nodes\n    // Be aware that the element could be removed by a later operation\n    callAllAnimationHooks(animations.componentWillDisappear, createClearAllCallback(children, parentDOM));\n  } else {\n    // Optimization for clearing dom\n    parentDOM.textContent = '';\n  }\n}\nfunction removeAllChildren(dom, vNode, children, animations) {\n  unmountAllChildren(children, animations);\n  if (vNode.flags & 8192 /* VNodeFlags.Fragment */) {\n    removeVNodeDOM(vNode, dom, animations);\n  } else {\n    clearDOM(dom, children, animations);\n  }\n}\n// Only add animations to queue in browser\nfunction addDisappearAnimationHook(animations, instanceOrRef, dom, flags, props) {\n  animations.componentWillDisappear.push(function (callback) {\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      instanceOrRef.componentWillDisappear(dom, callback);\n    } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      instanceOrRef.onComponentWillDisappear(dom, props, callback);\n    }\n  });\n}\n\nfunction wrapLinkEvent(nextValue) {\n  // This variable makes sure there is no \"this\" context in callback\n  var ev = nextValue.event;\n  return function (e) {\n    ev(nextValue.data, e);\n  };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n  if (isLinkEventObject(nextValue)) {\n    if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n      return;\n    }\n    nextValue = wrapLinkEvent(nextValue);\n  }\n  attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n  if (isNullOrUndef(nextAttrValue)) {\n    dom.removeAttribute('style');\n    return;\n  }\n  var domStyle = dom.style;\n  var style;\n  var value;\n  if (isString(nextAttrValue)) {\n    domStyle.cssText = nextAttrValue;\n    return;\n  }\n  if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n    for (style in nextAttrValue) {\n      // do not add a hasOwnProperty check here, it affects performance\n      value = nextAttrValue[style];\n      if (value !== lastAttrValue[style]) {\n        domStyle.setProperty(style, value);\n      }\n    }\n    for (style in lastAttrValue) {\n      if (isNullOrUndef(nextAttrValue[style])) {\n        domStyle.removeProperty(style);\n      }\n    }\n  } else {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n      domStyle.setProperty(style, value);\n    }\n  }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations) {\n  var lastHtml = lastValue && lastValue.__html || '';\n  var nextHtml = nextValue && nextValue.__html || '';\n  if (lastHtml !== nextHtml) {\n    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n      if (!isNull(lastVNode)) {\n        if (lastVNode.childFlags & 12 /* ChildFlags.MultipleChildren */) {\n          unmountAllChildren(lastVNode.children, animations);\n        } else if (lastVNode.childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n          unmount(lastVNode.children, animations);\n        }\n        lastVNode.children = null;\n        lastVNode.childFlags = 1 /* ChildFlags.HasInvalidChildren */;\n      }\n\n      dom.innerHTML = nextHtml;\n    }\n  }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations) {\n  switch (prop) {\n    case 'children':\n    case 'childrenType':\n    case 'className':\n    case 'defaultValue':\n    case 'key':\n    case 'multiple':\n    case 'ref':\n    case 'selectedIndex':\n      break;\n    case 'autoFocus':\n      dom.autofocus = !!nextValue;\n      break;\n    case 'allowfullscreen':\n    case 'autoplay':\n    case 'capture':\n    case 'checked':\n    case 'controls':\n    case 'default':\n    case 'disabled':\n    case 'hidden':\n    case 'indeterminate':\n    case 'loop':\n    case 'muted':\n    case 'novalidate':\n    case 'open':\n    case 'readOnly':\n    case 'required':\n    case 'reversed':\n    case 'scoped':\n    case 'seamless':\n    case 'selected':\n      dom[prop] = !!nextValue;\n      break;\n    case 'defaultChecked':\n    case 'value':\n    case 'volume':\n      if (hasControlledValue && prop === 'value') {\n        break;\n      }\n      var value = isNullOrUndef(nextValue) ? '' : nextValue;\n      if (dom[prop] !== value) {\n        dom[prop] = value;\n      }\n      break;\n    case 'style':\n      patchStyle(lastValue, nextValue, dom);\n      break;\n    case 'dangerouslySetInnerHTML':\n      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations);\n      break;\n    default:\n      if (syntheticEvents[prop]) {\n        handleSyntheticEvent(prop, lastValue, nextValue, dom);\n      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n        patchEvent(prop, lastValue, nextValue, dom);\n      } else if (isNullOrUndef(nextValue)) {\n        dom.removeAttribute(prop);\n      } else if (isSVG && namespaces[prop]) {\n        // We optimize for isSVG being false\n        // If we end up in this path we can read property again\n        dom.setAttributeNS(namespaces[prop], prop, nextValue);\n      } else {\n        dom.setAttribute(prop, nextValue);\n      }\n      break;\n  }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG, animations) {\n  var hasControlledValue = false;\n  var isFormElement = (flags & 448 /* VNodeFlags.FormElement */) > 0;\n  if (isFormElement) {\n    hasControlledValue = isControlledFormElement(props);\n    if (hasControlledValue) {\n      addFormElementEventHandlers(flags, dom, props);\n    }\n  }\n  for (var prop in props) {\n    // do not add a hasOwnProperty check here, it affects performance\n    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null, animations);\n  }\n  if (isFormElement) {\n    processElement(flags, vNode, dom, props, true, hasControlledValue);\n  }\n}\n\nfunction renderNewInput(instance, props, context) {\n  var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n  var childContext = context;\n  if (isFunction(instance.getChildContext)) {\n    childContext = combineFrom(context, instance.getChildContext());\n  }\n  instance.$CX = childContext;\n  return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n  var instance = new Component(props, context);\n  var usesNewAPI = instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);\n  instance.$SVG = isSVG;\n  instance.$L = lifecycle;\n  vNode.children = instance;\n  instance.$BS = false;\n  instance.context = context;\n  if (instance.props === EMPTY_OBJ) {\n    instance.props = props;\n  }\n  if (!usesNewAPI) {\n    if (isFunction(instance.componentWillMount)) {\n      instance.$BR = true;\n      instance.componentWillMount();\n      var pending = instance.$PS;\n      if (!isNull(pending)) {\n        var state = instance.state;\n        if (isNull(state)) {\n          instance.state = pending;\n        } else {\n          for (var key in pending) {\n            state[key] = pending[key];\n          }\n        }\n        instance.$PS = null;\n      }\n      instance.$BR = false;\n    }\n  } else {\n    instance.state = createDerivedState(instance, props, instance.state);\n  }\n  instance.$LI = renderNewInput(instance, props, context);\n  return instance;\n}\nfunction renderFunctionalComponent(vNode, context) {\n  var props = vNode.props || EMPTY_OBJ;\n  return vNode.flags & 32768 /* VNodeFlags.ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var flags = vNode.flags |= 16384 /* VNodeFlags.InUse */;\n  if (flags & 481 /* VNodeFlags.Element */) {\n    mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else if (flags & 4 /* VNodeFlags.ComponentClass */) {\n    mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n    mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else if (flags & 16 /* VNodeFlags.Text */) {\n    mountText(vNode, parentDOM, nextNode);\n  } else if (flags & 8192 /* VNodeFlags.Fragment */) {\n    mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle, animations);\n  } else if (flags & 1024 /* VNodeFlags.Portal */) {\n    mountPortal(vNode, context, parentDOM, nextNode, lifecycle, animations);\n  } else ;\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle, animations) {\n  mount(vNode.children, vNode.ref, context, false, null, lifecycle, animations);\n  var placeHolderVNode = createVoidVNode();\n  mountText(placeHolderVNode, parentDOM, nextNode);\n  vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle, animations) {\n  var children = vNode.children;\n  var childFlags = vNode.childFlags;\n  // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n  if (childFlags & 12 /* ChildFlags.MultipleChildren */ && children.length === 0) {\n    childFlags = vNode.childFlags = 2 /* ChildFlags.HasVNodeChildren */;\n    children = vNode.children = createVoidVNode();\n  }\n  if (childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n    mount(children, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else {\n    mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n  var dom = vNode.dom = document.createTextNode(vNode.children);\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var flags = vNode.flags;\n  var props = vNode.props;\n  var className = vNode.className;\n  var childFlags = vNode.childFlags;\n  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32 /* VNodeFlags.SvgElement */) > 0);\n  var children = vNode.children;\n  if (!isNullOrUndef(className) && className !== '') {\n    if (isSVG) {\n      dom.setAttribute('class', className);\n    } else {\n      dom.className = className;\n    }\n  }\n  if (childFlags === 16 /* ChildFlags.HasTextChildren */) {\n    setTextContent(dom, children);\n  } else if (childFlags !== 1 /* ChildFlags.HasInvalidChildren */) {\n    var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n    if (childFlags === 2 /* ChildFlags.HasVNodeChildren */) {\n      if (children.flags & 16384 /* VNodeFlags.InUse */) {\n        vNode.children = children = directClone(children);\n      }\n      mount(children, dom, context, childrenIsSVG, null, lifecycle, animations);\n    } else if (childFlags === 8 /* ChildFlags.HasKeyedChildren */ || childFlags === 4 /* ChildFlags.HasNonKeyedChildren */) {\n      mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle, animations);\n    }\n  }\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n  if (!isNull(props)) {\n    mountProps(vNode, flags, props, dom, isSVG, animations);\n  }\n  mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle, animations) {\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    if (child.flags & 16384 /* VNodeFlags.InUse */) {\n      children[i] = child = directClone(child);\n    }\n    mount(child, dom, context, isSVG, nextNode, lifecycle, animations);\n  }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n  // If we have a componentDidAppear on this component, we shouldn't allow children to animate so we're passing an dummy animations queue\n  var childAnimations = animations;\n  if (isFunction(instance.componentDidAppear)) {\n    childAnimations = new AnimationQueues();\n  }\n  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, childAnimations);\n  mountClassComponentCallbacks(vNode.ref, instance, lifecycle, animations);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var ref = vNode.ref;\n  // If we have a componentDidAppear on this component, we shouldn't allow children to animate so we're passing an dummy animations queue\n  var childAnimations = animations;\n  if (!isNullOrUndef(ref) && isFunction(ref.onComponentDidAppear)) {\n    childAnimations = new AnimationQueues();\n  }\n  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context)), parentDOM, context, isSVG, nextNode, lifecycle, childAnimations);\n  mountFunctionalComponentCallbacks(vNode, lifecycle, animations);\n}\nfunction createClassMountCallback(instance) {\n  return function () {\n    instance.componentDidMount();\n  };\n}\nfunction addAppearAnimationHook(animations, instanceOrRef, dom, flags, props) {\n  animations.componentDidAppear.push(function () {\n    if (flags & 4 /* VNodeFlags.ComponentClass */) {\n      instanceOrRef.componentDidAppear(dom);\n    } else if (flags & 8 /* VNodeFlags.ComponentFunction */) {\n      instanceOrRef.onComponentDidAppear(dom, props);\n    }\n  });\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle, animations) {\n  mountRef(ref, instance, lifecycle);\n  if (isFunction(instance.componentDidMount)) {\n    lifecycle.push(createClassMountCallback(instance));\n  }\n  if (isFunction(instance.componentDidAppear)) {\n    addAppearAnimationHook(animations, instance, instance.$LI.dom, 4 /* VNodeFlags.ComponentClass */, undefined);\n  }\n}\nfunction createOnMountCallback(ref, vNode) {\n  return function () {\n    ref.onComponentDidMount(findDOMFromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n  };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle, animations) {\n  var ref = vNode.ref;\n  if (!isNullOrUndef(ref)) {\n    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n    if (isFunction(ref.onComponentDidMount)) {\n      lifecycle.push(createOnMountCallback(ref, vNode));\n    }\n    if (isFunction(ref.onComponentDidAppear)) {\n      addAppearAnimationHook(animations, ref, findDOMFromVNode(vNode, true), 8 /* VNodeFlags.ComponentFunction */, vNode.props);\n    }\n  }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle, animations) {\n  unmount(lastVNode, animations);\n  if ((nextVNode.flags & lastVNode.flags & 1521 /* VNodeFlags.DOMRef */) !== 0) {\n    mount(nextVNode, null, context, isSVG, null, lifecycle, animations);\n    // Single DOM operation, when we have dom references available\n    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n  } else {\n    mount(nextVNode, parentDOM, context, isSVG, findDOMFromVNode(lastVNode, true), lifecycle, animations);\n    removeVNodeDOM(lastVNode, parentDOM, animations);\n  }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var nextFlags = nextVNode.flags |= 16384 /* VNodeFlags.InUse */;\n  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* VNodeFlags.ReCreate */) {\n    if (lastVNode.flags & 16384 /* VNodeFlags.InUse */) {\n      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle, animations);\n    } else {\n      // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n      mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n    }\n  } else if (nextFlags & 481 /* VNodeFlags.Element */) {\n    patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle, animations);\n  } else if (nextFlags & 4 /* VNodeFlags.ComponentClass */) {\n    patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else if (nextFlags & 8 /* VNodeFlags.ComponentFunction */) {\n    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n  } else if (nextFlags & 16 /* VNodeFlags.Text */) {\n    patchText(lastVNode, nextVNode);\n  } else if (nextFlags & 8192 /* VNodeFlags.Fragment */) {\n    patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle, animations);\n  } else {\n    patchPortal(lastVNode, nextVNode, context, lifecycle, animations);\n  }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n  if (lastChildren !== nextChildren) {\n    if (lastChildren !== '') {\n      parentDOM.firstChild.nodeValue = nextChildren;\n    } else {\n      setTextContent(parentDOM, nextChildren);\n    }\n  }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n  if (dom.textContent !== nextChildren) {\n    dom.textContent = nextChildren;\n  }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle, animations) {\n  var lastChildren = lastVNode.children;\n  var nextChildren = nextVNode.children;\n  var lastChildFlags = lastVNode.childFlags;\n  var nextChildFlags = nextVNode.childFlags;\n  var nextNode = null;\n  // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n  if (nextChildFlags & 12 /* ChildFlags.MultipleChildren */ && nextChildren.length === 0) {\n    nextChildFlags = nextVNode.childFlags = 2 /* ChildFlags.HasVNodeChildren */;\n    nextChildren = nextVNode.children = createVoidVNode();\n  }\n  var nextIsSingle = (nextChildFlags & 2 /* ChildFlags.HasVNodeChildren */) !== 0;\n  if (lastChildFlags & 12 /* ChildFlags.MultipleChildren */) {\n    var lastLen = lastChildren.length;\n    // We need to know Fragment's edge node when\n    if (\n    // It uses keyed algorithm\n    lastChildFlags & 8 /* ChildFlags.HasKeyedChildren */ && nextChildFlags & 8 /* ChildFlags.HasKeyedChildren */ ||\n    // It transforms from many to single\n    nextIsSingle ||\n    // It will append more nodes\n    !nextIsSingle && nextChildren.length > lastLen) {\n      // When fragment has multiple children there is always at least one vNode\n      nextNode = findDOMFromVNode(lastChildren[lastLen - 1], false).nextSibling;\n    }\n  }\n  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle, animations);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle, animations) {\n  var lastContainer = lastVNode.ref;\n  var nextContainer = nextVNode.ref;\n  var nextChildren = nextVNode.children;\n  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle, animations);\n  nextVNode.dom = lastVNode.dom;\n  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n    var node = nextChildren.dom;\n    removeChild(lastContainer, node);\n    appendChild(nextContainer, node);\n  }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle, animations) {\n  var dom = nextVNode.dom = lastVNode.dom;\n  var lastProps = lastVNode.props;\n  var nextProps = nextVNode.props;\n  var isFormElement = false;\n  var hasControlledValue = false;\n  var nextPropsOrEmpty;\n  isSVG = isSVG || (nextFlags & 32 /* VNodeFlags.SvgElement */) > 0;\n  // inlined patchProps  -- starts --\n  if (lastProps !== nextProps) {\n    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n    nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n    if (nextPropsOrEmpty !== EMPTY_OBJ) {\n      isFormElement = (nextFlags & 448 /* VNodeFlags.FormElement */) > 0;\n      if (isFormElement) {\n        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n      }\n      for (var prop in nextPropsOrEmpty) {\n        var lastValue = lastPropsOrEmpty[prop];\n        var nextValue = nextPropsOrEmpty[prop];\n        if (lastValue !== nextValue) {\n          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations);\n        }\n      }\n    }\n    if (lastPropsOrEmpty !== EMPTY_OBJ) {\n      for (var _prop in lastPropsOrEmpty) {\n        if (isNullOrUndef(nextPropsOrEmpty[_prop]) && !isNullOrUndef(lastPropsOrEmpty[_prop])) {\n          patchProp(_prop, lastPropsOrEmpty[_prop], null, dom, isSVG, hasControlledValue, lastVNode, animations);\n        }\n      }\n    }\n  }\n  var nextChildren = nextVNode.children;\n  var nextClassName = nextVNode.className;\n  // inlined patchProps  -- ends --\n  if (lastVNode.className !== nextClassName) {\n    if (isNullOrUndef(nextClassName)) {\n      dom.removeAttribute('class');\n    } else if (isSVG) {\n      dom.setAttribute('class', nextClassName);\n    } else {\n      dom.className = nextClassName;\n    }\n  }\n  if (nextFlags & 4096 /* VNodeFlags.ContentEditable */) {\n    patchContentEditableChildren(dom, nextChildren);\n  } else {\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle, animations);\n  }\n  if (isFormElement) {\n    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n  }\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, dom, lifecycle);\n  }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle, animations) {\n  unmount(lastChildren, animations);\n  mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMFromVNode(lastChildren, true), lifecycle, animations);\n  removeVNodeDOM(lastChildren, parentDOM, animations);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle, animations) {\n  switch (lastChildFlags) {\n    case 2 /* ChildFlags.HasVNodeChildren */:\n      switch (nextChildFlags) {\n        case 2 /* ChildFlags.HasVNodeChildren */:\n          patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n        case 1 /* ChildFlags.HasInvalidChildren */:\n          remove(lastChildren, parentDOM, animations);\n          break;\n        case 16 /* ChildFlags.HasTextChildren */:\n          unmount(lastChildren, animations);\n          setTextContent(parentDOM, nextChildren);\n          break;\n        default:\n          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle, animations);\n          break;\n      }\n      break;\n    case 1 /* ChildFlags.HasInvalidChildren */:\n      switch (nextChildFlags) {\n        case 2 /* ChildFlags.HasVNodeChildren */:\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n        case 1 /* ChildFlags.HasInvalidChildren */:\n          break;\n        case 16 /* ChildFlags.HasTextChildren */:\n          setTextContent(parentDOM, nextChildren);\n          break;\n        default:\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n      }\n      break;\n    case 16 /* ChildFlags.HasTextChildren */:\n      switch (nextChildFlags) {\n        case 16 /* ChildFlags.HasTextChildren */:\n          patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n          break;\n        case 2 /* ChildFlags.HasVNodeChildren */:\n          clearDOM(parentDOM, lastChildren, animations);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n        case 1 /* ChildFlags.HasInvalidChildren */:\n          clearDOM(parentDOM, lastChildren, animations);\n          break;\n        default:\n          clearDOM(parentDOM, lastChildren, animations);\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n      }\n      break;\n    default:\n      switch (nextChildFlags) {\n        case 16 /* ChildFlags.HasTextChildren */:\n          unmountAllChildren(lastChildren, animations);\n          setTextContent(parentDOM, nextChildren);\n          break;\n        case 2 /* ChildFlags.HasVNodeChildren */:\n          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n          break;\n        case 1 /* ChildFlags.HasInvalidChildren */:\n          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);\n          break;\n        default:\n          var lastLength = lastChildren.length | 0;\n          var nextLength = nextChildren.length | 0;\n          // Fast path's for both algorithms\n          if (lastLength === 0) {\n            if (nextLength > 0) {\n              mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n            }\n          } else if (nextLength === 0) {\n            removeAllChildren(parentDOM, parentVNode, lastChildren, animations);\n          } else if (nextChildFlags === 8 /* ChildFlags.HasKeyedChildren */ && lastChildFlags === 8 /* ChildFlags.HasKeyedChildren */) {\n            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle, animations);\n          } else {\n            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle, animations);\n          }\n          break;\n      }\n      break;\n  }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n  lifecycle.push(function () {\n    instance.componentDidUpdate(lastProps, lastState, snapshot);\n  });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle, animations) {\n  var lastState = instance.state;\n  var lastProps = instance.props;\n  var usesNewAPI = Boolean(instance.$N);\n  var hasSCU = isFunction(instance.shouldComponentUpdate);\n  if (usesNewAPI) {\n    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n  }\n  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {\n    if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n      instance.componentWillUpdate(nextProps, nextState, context);\n    }\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n    var snapshot = null;\n    var nextInput = renderNewInput(instance, nextProps, context);\n    if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n    }\n    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, animations);\n    // Don't update Last input, until patch has been successfully executed\n    instance.$LI = nextInput;\n    if (isFunction(instance.componentDidUpdate)) {\n      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n    }\n  } else {\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n  }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var instance = nextVNode.children = lastVNode.children;\n  // If Component has crashed, ignore it to stay functional\n  if (isNull(instance)) {\n    return;\n  }\n  instance.$L = lifecycle;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  var nextState = instance.state;\n  if (!instance.$N) {\n    if (isFunction(instance.componentWillReceiveProps)) {\n      instance.$BR = true;\n      instance.componentWillReceiveProps(nextProps, context);\n      // If instance component was removed during its own update do nothing.\n      if (instance.$UN) {\n        return;\n      }\n      instance.$BR = false;\n    }\n    if (!isNull(instance.$PS)) {\n      nextState = combineFrom(nextState, instance.$PS);\n      instance.$PS = null;\n    }\n  }\n  updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle, animations);\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, instance, lifecycle);\n  }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle, animations) {\n  var shouldUpdate = true;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastProps = lastVNode.props;\n  var nextHooksDefined = !isNullOrUndef(nextRef);\n  var lastInput = lastVNode.children;\n  if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n  }\n  if (shouldUpdate !== false) {\n    if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n      nextRef.onComponentWillUpdate(lastProps, nextProps);\n    }\n    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n    patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle, animations);\n    nextVNode.children = nextInput;\n    if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n      nextRef.onComponentDidUpdate(lastProps, nextProps);\n    }\n  } else {\n    nextVNode.children = lastInput;\n  }\n}\nfunction patchText(lastVNode, nextVNode) {\n  var nextText = nextVNode.children;\n  var dom = nextVNode.dom = lastVNode.dom;\n  if (nextText !== lastVNode.children) {\n    dom.nodeValue = nextText;\n  }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle, animations) {\n  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n  var i = 0;\n  var nextChild;\n  var lastChild;\n  for (; i < commonLength; ++i) {\n    nextChild = nextChildren[i];\n    lastChild = lastChildren[i];\n    if (nextChild.flags & 16384 /* VNodeFlags.InUse */) {\n      nextChild = nextChildren[i] = directClone(nextChild);\n    }\n    patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle, animations);\n    lastChildren[i] = nextChild;\n  }\n  if (lastChildrenLength < nextChildrenLength) {\n    for (i = commonLength; i < nextChildrenLength; ++i) {\n      nextChild = nextChildren[i];\n      if (nextChild.flags & 16384 /* VNodeFlags.InUse */) {\n        nextChild = nextChildren[i] = directClone(nextChild);\n      }\n      mount(nextChild, dom, context, isSVG, nextNode, lifecycle, animations);\n    }\n  } else if (lastChildrenLength > nextChildrenLength) {\n    for (i = commonLength; i < lastChildrenLength; ++i) {\n      remove(lastChildren[i], dom, animations);\n    }\n  }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle, animations) {\n  var aEnd = aLength - 1;\n  var bEnd = bLength - 1;\n  var j = 0;\n  var aNode = a[j];\n  var bNode = b[j];\n  var nextPos;\n  var nextNode;\n  // Step 1\n  // tslint:disable-next-line\n  outer: {\n    // Sync nodes with the same key at the beginning.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n        b[j] = bNode = directClone(bNode);\n      }\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle, animations);\n      a[j] = bNode;\n      ++j;\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n      aNode = a[j];\n      bNode = b[j];\n    }\n    aNode = a[aEnd];\n    bNode = b[bEnd];\n    // Sync nodes with the same key at the end.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n        b[bEnd] = bNode = directClone(bNode);\n      }\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle, animations);\n      a[aEnd] = bNode;\n      aEnd--;\n      bEnd--;\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n      aNode = a[aEnd];\n      bNode = b[bEnd];\n    }\n  }\n  if (j > aEnd) {\n    if (j <= bEnd) {\n      nextPos = bEnd + 1;\n      nextNode = nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge;\n      while (j <= bEnd) {\n        bNode = b[j];\n        if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n          b[j] = bNode = directClone(bNode);\n        }\n        ++j;\n        mount(bNode, dom, context, isSVG, nextNode, lifecycle, animations);\n      }\n    }\n  } else if (j > bEnd) {\n    while (j <= aEnd) {\n      remove(a[j++], dom, animations);\n    }\n  } else {\n    patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations);\n  }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations) {\n  var aNode;\n  var bNode;\n  var nextPos = 0;\n  var i = 0;\n  var aStart = j;\n  var bStart = j;\n  var aLeft = aEnd - j + 1;\n  var bLeft = bEnd - j + 1;\n  var sources = new Int32Array(bLeft + 1);\n  // Keep track if its possible to remove whole DOM using textContent = '';\n  var canRemoveWholeContent = aLeft === aLength;\n  var moved = false;\n  var pos = 0;\n  var patched = 0;\n  // When sizes are small, just loop them through\n  if (bLength < 4 || (aLeft | bLeft) < 32) {\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n      if (patched < bLeft) {\n        for (j = bStart; j <= bEnd; j++) {\n          bNode = b[j];\n          if (aNode.key === bNode.key) {\n            sources[j - bStart] = i + 1;\n            if (canRemoveWholeContent) {\n              canRemoveWholeContent = false;\n              while (aStart < i) {\n                remove(a[aStart++], dom, animations);\n              }\n            }\n            if (pos > j) {\n              moved = true;\n            } else {\n              pos = j;\n            }\n            if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n              b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle, animations);\n            ++patched;\n            break;\n          }\n        }\n        if (!canRemoveWholeContent && j > bEnd) {\n          remove(aNode, dom, animations);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom, animations);\n      }\n    }\n  } else {\n    var keyIndex = {};\n    // Map keys by their index\n    for (i = bStart; i <= bEnd; ++i) {\n      keyIndex[b[i].key] = i;\n    }\n    // Try to patch same keys\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n      if (patched < bLeft) {\n        j = keyIndex[aNode.key];\n        if (j !== void 0) {\n          if (canRemoveWholeContent) {\n            canRemoveWholeContent = false;\n            while (i > aStart) {\n              remove(a[aStart++], dom, animations);\n            }\n          }\n          sources[j - bStart] = i + 1;\n          if (pos > j) {\n            moved = true;\n          } else {\n            pos = j;\n          }\n          bNode = b[j];\n          if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n            b[j] = bNode = directClone(bNode);\n          }\n          patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle, animations);\n          ++patched;\n        } else if (!canRemoveWholeContent) {\n          remove(aNode, dom, animations);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom, animations);\n      }\n    }\n  }\n  // fast-path: if nothing patched remove all old and add all new\n  if (canRemoveWholeContent) {\n    removeAllChildren(dom, parentVNode, a, animations);\n    mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle, animations);\n  } else if (moved) {\n    var seq = lis_algorithm(sources);\n    j = seq.length - 1;\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n        if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n          b[pos] = bNode = directClone(bNode);\n        }\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);\n      } else if (j < 0 || i !== seq[j]) {\n        pos = i + bStart;\n        bNode = b[pos];\n        nextPos = pos + 1;\n        // --- the DOM-node is moved by a call to insertAppend\n        moveVNodeDOM(parentVNode, bNode, dom, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, animations);\n      } else {\n        j--;\n      }\n    }\n    // Invoke move animations when all moves have been calculated\n    if (animations.componentWillMove.length > 0) {\n      callAllMoveAnimationHooks(animations.componentWillMove);\n    }\n  } else if (patched !== bLeft) {\n    // when patched count doesn't match b length we need to insert those new ones\n    // loop backwards so we can use insertBefore\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n        if (bNode.flags & 16384 /* VNodeFlags.InUse */) {\n          b[pos] = bNode = directClone(bNode);\n        }\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);\n      }\n    }\n  }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n  var arrI = 0;\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var u = 0;\n  var v = 0;\n  var c = 0;\n  var len = arr.length;\n  if (len > maxLen) {\n    maxLen = len;\n    result = new Int32Array(len);\n    p = new Int32Array(len);\n  }\n  for (; i < len; ++i) {\n    arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[k];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result[++k] = i;\n        continue;\n      }\n      u = 0;\n      v = k;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = k + 1;\n  var seq = new Int32Array(u);\n  v = result[u - 1];\n  while (u-- > 0) {\n    seq[u] = v;\n    v = p[v];\n    result[u] = 0;\n  }\n  return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n  /*\n   * Defining $EV and $V properties on Node.prototype\n   * fixes v8 \"wrong map\" de-optimization\n   */\n  if (window.Node) {\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n  }\n}\nfunction __render(input, parentDOM, callback, context) {\n  var lifecycle = [];\n  var animations = new AnimationQueues();\n  var rootInput = parentDOM.$V;\n  renderCheck.v = true;\n  if (isNullOrUndef(rootInput)) {\n    if (!isNullOrUndef(input)) {\n      if (input.flags & 16384 /* VNodeFlags.InUse */) {\n        input = directClone(input);\n      }\n      mount(input, parentDOM, context, false, null, lifecycle, animations);\n      parentDOM.$V = input;\n      rootInput = input;\n    }\n  } else {\n    if (isNullOrUndef(input)) {\n      remove(rootInput, parentDOM, animations);\n      parentDOM.$V = null;\n    } else {\n      if (input.flags & 16384 /* VNodeFlags.InUse */) {\n        input = directClone(input);\n      }\n      patch(rootInput, input, parentDOM, context, false, null, lifecycle, animations);\n      rootInput = parentDOM.$V = input;\n    }\n  }\n  callAll(lifecycle);\n  callAllAnimationHooks(animations.componentDidAppear);\n  renderCheck.v = false;\n  if (isFunction(callback)) {\n    callback();\n  }\n  if (isFunction(options.renderComplete)) {\n    options.renderComplete(rootInput, parentDOM);\n  }\n}\nfunction render(input, parentDOM, callback, context) {\n  if (callback === void 0) {\n    callback = null;\n  }\n  if (context === void 0) {\n    context = EMPTY_OBJ;\n  }\n  __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n  return function renderer(lastInput, nextInput, callback, context) {\n    if (!parentDOM) {\n      parentDOM = lastInput;\n    }\n    render(nextInput, parentDOM, callback, context);\n  };\n}\n\nvar COMPONENTS_QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : function (a) {\n  window.setTimeout(a, 0);\n};\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n  var pending = component.$PS;\n  if (isFunction(newState)) {\n    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n  }\n  if (isNullOrUndef(pending)) {\n    component.$PS = newState;\n  } else {\n    for (var stateKey in newState) {\n      pending[stateKey] = newState[stateKey];\n    }\n  }\n  if (!component.$BR) {\n    if (!renderCheck.v) {\n      if (COMPONENTS_QUEUE.length === 0) {\n        applyState(component, force);\n        if (isFunction(callback)) {\n          callback.call(component);\n        }\n        return;\n      }\n    }\n    if (COMPONENTS_QUEUE.indexOf(component) === -1) {\n      COMPONENTS_QUEUE.push(component);\n    }\n    if (force) {\n      component.$F = true;\n    }\n    if (!microTaskPending) {\n      microTaskPending = true;\n      nextTick(rerender);\n    }\n    if (isFunction(callback)) {\n      var QU = component.$QU;\n      if (!QU) {\n        QU = component.$QU = [];\n      }\n      QU.push(callback);\n    }\n  } else if (isFunction(callback)) {\n    component.$L.push(callback.bind(component));\n  }\n}\nfunction callSetStateCallbacks(component) {\n  var queue = component.$QU;\n  for (var i = 0; i < queue.length; ++i) {\n    queue[i].call(component);\n  }\n  component.$QU = null;\n}\nfunction rerender() {\n  var component;\n  microTaskPending = false;\n  while (component = COMPONENTS_QUEUE.shift()) {\n    if (!component.$UN) {\n      var force = component.$F;\n      component.$F = false;\n      applyState(component, force);\n      if (component.$QU) {\n        callSetStateCallbacks(component);\n      }\n    }\n  }\n}\nfunction applyState(component, force) {\n  if (force || !component.$BR) {\n    var pendingState = component.$PS;\n    component.$PS = null;\n    var lifecycle = [];\n    var animations = new AnimationQueues();\n    renderCheck.v = true;\n    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMFromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle, animations);\n    callAll(lifecycle);\n    callAllAnimationHooks(animations.componentDidAppear);\n    renderCheck.v = false;\n  } else {\n    component.state = component.$PS;\n    component.$PS = null;\n  }\n}\nvar Component = /*#__PURE__*/function () {\n  // Force update flag\n  function Component(props, context) {\n    // Public\n    this.state = null;\n    this.props = void 0;\n    this.context = void 0;\n    this.displayName = void 0;\n    // Internal properties\n    this.$BR = false;\n    // BLOCK RENDER\n    this.$BS = true;\n    // BLOCK STATE\n    this.$PS = null;\n    // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null;\n    // LAST INPUT\n    this.$UN = false;\n    // UNMOUNTED\n    this.$CX = null;\n    // CHILDCONTEXT\n    this.$QU = null;\n    // QUEUE\n    this.$N = false;\n    // Uses new lifecycle API Flag\n    this.$SSR = void 0;\n    // Server side rendering flag, true when rendering on server, non existent on client\n    this.$L = null;\n    // Current lifecycle of this component\n    this.$SVG = false;\n    // Flag to keep track if component is inside SVG tree\n    this.$F = false;\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n  }\n  var _proto = Component.prototype;\n  _proto.forceUpdate = function forceUpdate(callback) {\n    if (this.$UN) {\n      return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n  };\n  _proto.setState = function setState(newState, callback) {\n    if (this.$UN) {\n      return;\n    }\n    if (!this.$BS) {\n      queueStateChanges(this, newState, callback, false);\n    }\n  };\n  // @ts-expect-error TS6133\n  _proto.render = function render(props, state, context) {\n    return null;\n  };\n  return Component;\n}();\nComponent.defaultProps = null;\n\nvar version = \"8.2.2\";\n\nexport { AnimationQueues, Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMFromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };\n","export * from './dist/index.esm.js';\n\nif (process.env.NODE_ENV !== 'production') {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var pathToRegExp = require('path-to-regexp')\r\n\r\n/**\r\n * Expose `pathToRegexp` as ES6 module\r\n */\r\nmodule.exports = pathToRegExp;\r\nmodule.exports.parse = pathToRegExp.parse\r\nmodule.exports.compile = pathToRegExp.compile\r\nmodule.exports.tokensToFunction = pathToRegExp.tokensToFunction\r\nmodule.exports.tokensToRegExp = pathToRegExp.tokensToRegExp\r\nmodule.exports['default'] = module.exports;\r\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","import { fetch_auth_get, fetch_auth_post } from \"./api_with_auth\";\nexport async function get_list_jobs() {\n    let url = \"/api/jobs\";\n    let data = await fetch_auth_get(url);\n    return data.result;\n}\nexport async function get_job(job_id) {\n    let url = `/api/job/${job_id}`;\n    let data = await fetch_auth_get(url);\n    return data.result;\n}\nexport async function register_new_job(job) {\n    let url = \"/api/job/create\";\n    let data = await fetch_auth_post(url, job);\n    return data.result;\n}\n","import { fetch_auth_post } from \"./api_with_auth\";\nexport async function list_quotation_by_job(job_id) {\n    let url = \"/api/quotations\";\n    let search_criteria = {\n        \"job_id\": job_id\n    };\n    let data = await fetch_auth_post(url, search_criteria);\n    return data.result;\n}\nexport async function register_new_quotation(quotation) {\n    let url = \"/api/quotation/create\";\n    let data = await fetch_auth_post(url, quotation);\n    return data.result;\n}\n","const DEFAULT_HEADERS = { 'Accept': 'application/json', 'Content-Type': 'application/json' };\nexport function is_login() {\n    return 'jwt_xapp' in window && window['jwt_xapp'] != undefined;\n}\nexport function session_is_owner(user_id) {\n    if (is_login()) {\n        return 'jwt_xapp_user_id' in window && window['jwt_xapp_user_id'] == user_id;\n    }\n    else {\n        return false;\n    }\n}\nexport function if_login_inject_authorization_header(headers) {\n    if (is_login() && 'jwt_xapp' in window) {\n        let jwt_xapp = window['jwt_xapp'];\n        headers['Authorization'] = 'Bearer ' + jwt_xapp;\n    }\n    return headers;\n}\nexport async function fetch_auth_post(url, body, headers = DEFAULT_HEADERS) {\n    headers = if_login_inject_authorization_header(headers);\n    let response = await fetch(url, {\n        headers: headers,\n        method: \"POST\",\n        body: JSON.stringify(body)\n    });\n    return await response.json();\n}\nexport async function fetch_auth_get(url, headers = DEFAULT_HEADERS) {\n    headers = if_login_inject_authorization_header(headers);\n    let response = await fetch(url, {\n        headers: headers,\n        method: \"GET\"\n    });\n    return await response.json();\n}\n","export class InmmutableModel {\n    data;\n    constructor(data) {\n        this.data = data;\n    }\n    clone_data() {\n        return JSON.parse(JSON.stringify(this.data));\n    }\n    raw() {\n        return this.data;\n    }\n}\n","import { InmmutableModel } from \"./inmmutable_model\";\nexport class Job extends InmmutableModel {\n    constructor(job) {\n        super(job);\n    }\n    static default() {\n        let data = {\n            title: \"\",\n            description: \"\",\n            budget_range: \"\"\n        };\n        return new Job(data);\n    }\n    clone() {\n        return new Job(this.clone_data());\n    }\n    setTitle(title) {\n        this.data.title = title;\n    }\n    setBudgetRange(budget_range) {\n        this.data.budget_range = budget_range;\n    }\n    setDescription(description) {\n        this.data.description = description;\n    }\n}\n","import { InmmutableModel } from \"./inmmutable_model\";\nexport class Quotation extends InmmutableModel {\n    constructor(quote) {\n        super(quote);\n    }\n    static default(job_id) {\n        let data = {\n            job_id: job_id,\n            description: \"\",\n            total_amount: 0.0\n        };\n        return new Quotation(data);\n    }\n    clone() {\n        return new Quotation(this.clone_data());\n    }\n    setTotalAmount(total_amount) {\n        this.data.total_amount = parseFloat(total_amount);\n    }\n    setDescription(description) {\n        this.data.description = description;\n    }\n}\n","import { InmmutableModel } from \"./inmmutable_model\";\n// This should be take from API.\nconst XRP_TO_DOLARS = 0.71;\nexport class XRPValue extends InmmutableModel {\n    static default(value_txt) {\n        let data = {\n            value: 0.0,\n            value_txt: \"0.0\",\n            drops: \"0\",\n            on_dolars: \"0.00\"\n        };\n        let xrp = new XRPValue(data);\n        xrp.trySetValueFromStr(value_txt);\n        return xrp;\n    }\n    clone() {\n        return new XRPValue(this.clone_data());\n    }\n    calc_dolars() {\n        this.data.on_dolars = (this.data.value * XRP_TO_DOLARS).toFixed(2);\n    }\n    trySetValueFromStr(value_txt) {\n        let is_empty = value_txt == \"\";\n        if (is_empty) {\n            value_txt = \"0\";\n        }\n        let is_last_char_is_dot = value_txt.slice(-1) == '.';\n        if (is_last_char_is_dot) {\n            value_txt += \"0\";\n        }\n        const regex = /^(?:\\d{1,8}(?:\\.\\d{1,6})?|\\.\\d{1,6})$/;\n        let new_canditate_value = parseFloat(value_txt);\n        if (!Number.isNaN(new_canditate_value) && regex.test(value_txt)) {\n            if (new_canditate_value >= 0) {\n                this.data.value = new_canditate_value;\n                this.data.value_txt = value_txt;\n                let drops = (new_canditate_value / 0.000001).toFixed(0);\n                this.data.drops = drops;\n                this.calc_dolars();\n            }\n        }\n    }\n}\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\tif (cachedModule.error !== undefined) throw cachedModule.error;\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\ttry {\n\t\tvar execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };\n\t\t__webpack_require__.i.forEach(function(handler) { handler(execOptions); });\n\t\tmodule = execOptions.module;\n\t\texecOptions.factory.call(module.exports, module, module.exports, execOptions.require);\n\t} catch(e) {\n\t\tmodule.error = e;\n\t\tthrow e;\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n// expose the module execution interceptor\n__webpack_require__.i = [];\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference all chunks\n__webpack_require__.hu = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + __webpack_require__.h() + \".hot-update.js\";\n};","__webpack_require__.hmrF = () => (\"main.\" + __webpack_require__.h() + \".hot-update.json\");","__webpack_require__.h = () => (\"cdb7cef45a672ed04d6b\")","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"inferno-boilerplate:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var currentModuleData = {};\nvar installedModules = __webpack_require__.c;\n\n// module and require creation\nvar currentChildModule;\nvar currentParents = [];\n\n// status\nvar registeredStatusHandlers = [];\nvar currentStatus = \"idle\";\n\n// while downloading\nvar blockingPromises = 0;\nvar blockingPromisesWaiting = [];\n\n// The update info\nvar currentUpdateApplyHandlers;\nvar queuedInvalidatedModules;\n\n// eslint-disable-next-line no-unused-vars\n__webpack_require__.hmrD = currentModuleData;\n\n__webpack_require__.i.push(function (options) {\n\tvar module = options.module;\n\tvar require = createRequire(options.require, options.id);\n\tmodule.hot = createModuleHotObject(options.id, module);\n\tmodule.parents = currentParents;\n\tmodule.children = [];\n\tcurrentParents = [];\n\toptions.require = require;\n});\n\n__webpack_require__.hmrC = {};\n__webpack_require__.hmrI = {};\n\nfunction createRequire(require, moduleId) {\n\tvar me = installedModules[moduleId];\n\tif (!me) return require;\n\tvar fn = function (request) {\n\t\tif (me.hot.active) {\n\t\t\tif (installedModules[request]) {\n\t\t\t\tvar parents = installedModules[request].parents;\n\t\t\t\tif (parents.indexOf(moduleId) === -1) {\n\t\t\t\t\tparents.push(moduleId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentParents = [moduleId];\n\t\t\t\tcurrentChildModule = request;\n\t\t\t}\n\t\t\tif (me.children.indexOf(request) === -1) {\n\t\t\t\tme.children.push(request);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t\"[HMR] unexpected require(\" +\n\t\t\t\t\trequest +\n\t\t\t\t\t\") from disposed module \" +\n\t\t\t\t\tmoduleId\n\t\t\t);\n\t\t\tcurrentParents = [];\n\t\t}\n\t\treturn require(request);\n\t};\n\tvar createPropertyDescriptor = function (name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn require[name];\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\trequire[name] = value;\n\t\t\t}\n\t\t};\n\t};\n\tfor (var name in require) {\n\t\tif (Object.prototype.hasOwnProperty.call(require, name) && name !== \"e\") {\n\t\t\tObject.defineProperty(fn, name, createPropertyDescriptor(name));\n\t\t}\n\t}\n\tfn.e = function (chunkId) {\n\t\treturn trackBlockingPromise(require.e(chunkId));\n\t};\n\treturn fn;\n}\n\nfunction createModuleHotObject(moduleId, me) {\n\tvar _main = currentChildModule !== moduleId;\n\tvar hot = {\n\t\t// private stuff\n\t\t_acceptedDependencies: {},\n\t\t_acceptedErrorHandlers: {},\n\t\t_declinedDependencies: {},\n\t\t_selfAccepted: false,\n\t\t_selfDeclined: false,\n\t\t_selfInvalidated: false,\n\t\t_disposeHandlers: [],\n\t\t_main: _main,\n\t\t_requireSelf: function () {\n\t\t\tcurrentParents = me.parents.slice();\n\t\t\tcurrentChildModule = _main ? undefined : moduleId;\n\t\t\t__webpack_require__(moduleId);\n\t\t},\n\n\t\t// Module API\n\t\tactive: true,\n\t\taccept: function (dep, callback, errorHandler) {\n\t\t\tif (dep === undefined) hot._selfAccepted = true;\n\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n\t\t\telse if (typeof dep === \"object\" && dep !== null) {\n\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function () {};\n\t\t\t\t\thot._acceptedErrorHandlers[dep[i]] = errorHandler;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thot._acceptedDependencies[dep] = callback || function () {};\n\t\t\t\thot._acceptedErrorHandlers[dep] = errorHandler;\n\t\t\t}\n\t\t},\n\t\tdecline: function (dep) {\n\t\t\tif (dep === undefined) hot._selfDeclined = true;\n\t\t\telse if (typeof dep === \"object\" && dep !== null)\n\t\t\t\tfor (var i = 0; i < dep.length; i++)\n\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n\t\t\telse hot._declinedDependencies[dep] = true;\n\t\t},\n\t\tdispose: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\taddDisposeHandler: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\tremoveDisposeHandler: function (callback) {\n\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n\t\t},\n\t\tinvalidate: function () {\n\t\t\tthis._selfInvalidated = true;\n\t\t\tswitch (currentStatus) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\tcurrentUpdateApplyHandlers = [];\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tsetStatus(\"ready\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ready\":\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"prepare\":\n\t\t\t\tcase \"check\":\n\t\t\t\tcase \"dispose\":\n\t\t\t\tcase \"apply\":\n\t\t\t\t\t(queuedInvalidatedModules = queuedInvalidatedModules || []).push(\n\t\t\t\t\t\tmoduleId\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// ignore requests in error states\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\t// Management API\n\t\tcheck: hotCheck,\n\t\tapply: hotApply,\n\t\tstatus: function (l) {\n\t\t\tif (!l) return currentStatus;\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\taddStatusHandler: function (l) {\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\tremoveStatusHandler: function (l) {\n\t\t\tvar idx = registeredStatusHandlers.indexOf(l);\n\t\t\tif (idx >= 0) registeredStatusHandlers.splice(idx, 1);\n\t\t},\n\n\t\t//inherit from previous dispose call\n\t\tdata: currentModuleData[moduleId]\n\t};\n\tcurrentChildModule = undefined;\n\treturn hot;\n}\n\nfunction setStatus(newStatus) {\n\tcurrentStatus = newStatus;\n\tvar results = [];\n\n\tfor (var i = 0; i < registeredStatusHandlers.length; i++)\n\t\tresults[i] = registeredStatusHandlers[i].call(null, newStatus);\n\n\treturn Promise.all(results);\n}\n\nfunction unblock() {\n\tif (--blockingPromises === 0) {\n\t\tsetStatus(\"ready\").then(function () {\n\t\t\tif (blockingPromises === 0) {\n\t\t\t\tvar list = blockingPromisesWaiting;\n\t\t\t\tblockingPromisesWaiting = [];\n\t\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i]();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction trackBlockingPromise(promise) {\n\tswitch (currentStatus) {\n\t\tcase \"ready\":\n\t\t\tsetStatus(\"prepare\");\n\t\t/* fallthrough */\n\t\tcase \"prepare\":\n\t\t\tblockingPromises++;\n\t\t\tpromise.then(unblock, unblock);\n\t\t\treturn promise;\n\t\tdefault:\n\t\t\treturn promise;\n\t}\n}\n\nfunction waitForBlockingPromises(fn) {\n\tif (blockingPromises === 0) return fn();\n\treturn new Promise(function (resolve) {\n\t\tblockingPromisesWaiting.push(function () {\n\t\t\tresolve(fn());\n\t\t});\n\t});\n}\n\nfunction hotCheck(applyOnUpdate) {\n\tif (currentStatus !== \"idle\") {\n\t\tthrow new Error(\"check() is only allowed in idle status\");\n\t}\n\treturn setStatus(\"check\")\n\t\t.then(__webpack_require__.hmrM)\n\t\t.then(function (update) {\n\t\t\tif (!update) {\n\t\t\t\treturn setStatus(applyInvalidatedModules() ? \"ready\" : \"idle\").then(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn setStatus(\"prepare\").then(function () {\n\t\t\t\tvar updatedModules = [];\n\t\t\t\tcurrentUpdateApplyHandlers = [];\n\n\t\t\t\treturn Promise.all(\n\t\t\t\t\tObject.keys(__webpack_require__.hmrC).reduce(function (\n\t\t\t\t\t\tpromises,\n\t\t\t\t\t\tkey\n\t\t\t\t\t) {\n\t\t\t\t\t\t__webpack_require__.hmrC[key](\n\t\t\t\t\t\t\tupdate.c,\n\t\t\t\t\t\t\tupdate.r,\n\t\t\t\t\t\t\tupdate.m,\n\t\t\t\t\t\t\tpromises,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers,\n\t\t\t\t\t\t\tupdatedModules\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn promises;\n\t\t\t\t\t},\n\t\t\t\t\t[])\n\t\t\t\t).then(function () {\n\t\t\t\t\treturn waitForBlockingPromises(function () {\n\t\t\t\t\t\tif (applyOnUpdate) {\n\t\t\t\t\t\t\treturn internalApply(applyOnUpdate);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn setStatus(\"ready\").then(function () {\n\t\t\t\t\t\t\t\treturn updatedModules;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction hotApply(options) {\n\tif (currentStatus !== \"ready\") {\n\t\treturn Promise.resolve().then(function () {\n\t\t\tthrow new Error(\n\t\t\t\t\"apply() is only allowed in ready status (state: \" +\n\t\t\t\t\tcurrentStatus +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t});\n\t}\n\treturn internalApply(options);\n}\n\nfunction internalApply(options) {\n\toptions = options || {};\n\n\tapplyInvalidatedModules();\n\n\tvar results = currentUpdateApplyHandlers.map(function (handler) {\n\t\treturn handler(options);\n\t});\n\tcurrentUpdateApplyHandlers = undefined;\n\n\tvar errors = results\n\t\t.map(function (r) {\n\t\t\treturn r.error;\n\t\t})\n\t\t.filter(Boolean);\n\n\tif (errors.length > 0) {\n\t\treturn setStatus(\"abort\").then(function () {\n\t\t\tthrow errors[0];\n\t\t});\n\t}\n\n\t// Now in \"dispose\" phase\n\tvar disposePromise = setStatus(\"dispose\");\n\n\tresults.forEach(function (result) {\n\t\tif (result.dispose) result.dispose();\n\t});\n\n\t// Now in \"apply\" phase\n\tvar applyPromise = setStatus(\"apply\");\n\n\tvar error;\n\tvar reportError = function (err) {\n\t\tif (!error) error = err;\n\t};\n\n\tvar outdatedModules = [];\n\tresults.forEach(function (result) {\n\t\tif (result.apply) {\n\t\t\tvar modules = result.apply(reportError);\n\t\t\tif (modules) {\n\t\t\t\tfor (var i = 0; i < modules.length; i++) {\n\t\t\t\t\toutdatedModules.push(modules[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Promise.all([disposePromise, applyPromise]).then(function () {\n\t\t// handle errors in accept handlers and self accepted module load\n\t\tif (error) {\n\t\t\treturn setStatus(\"fail\").then(function () {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\n\t\tif (queuedInvalidatedModules) {\n\t\t\treturn internalApply(options).then(function (list) {\n\t\t\t\toutdatedModules.forEach(function (moduleId) {\n\t\t\t\t\tif (list.indexOf(moduleId) < 0) list.push(moduleId);\n\t\t\t\t});\n\t\t\t\treturn list;\n\t\t\t});\n\t\t}\n\n\t\treturn setStatus(\"idle\").then(function () {\n\t\t\treturn outdatedModules;\n\t\t});\n\t});\n}\n\nfunction applyInvalidatedModules() {\n\tif (queuedInvalidatedModules) {\n\t\tif (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];\n\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\tqueuedInvalidatedModules.forEach(function (moduleId) {\n\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\tmoduleId,\n\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t\tqueuedInvalidatedModules = undefined;\n\t\treturn true;\n\t}\n}","__webpack_require__.p = \"http://localhost:8080/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\nvar currentUpdatedModulesList;\nvar waitingUpdateResolves = {};\nfunction loadUpdateChunk(chunkId, updatedModulesList) {\n\tcurrentUpdatedModulesList = updatedModulesList;\n\treturn new Promise((resolve, reject) => {\n\t\twaitingUpdateResolves[chunkId] = resolve;\n\t\t// start update chunk loading\n\t\tvar url = __webpack_require__.p + __webpack_require__.hu(chunkId);\n\t\t// create error before stack unwound to get useful stacktrace later\n\t\tvar error = new Error();\n\t\tvar loadingEnded = (event) => {\n\t\t\tif(waitingUpdateResolves[chunkId]) {\n\t\t\t\twaitingUpdateResolves[chunkId] = undefined\n\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\terror.message = 'Loading hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\terror.type = errorType;\n\t\t\t\terror.request = realSrc;\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\t\t__webpack_require__.l(url, loadingEnded);\n\t});\n}\n\nself[\"webpackHotUpdateinferno_boilerplate\"] = (chunkId, moreModules, runtime) => {\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\tcurrentUpdate[moduleId] = moreModules[moduleId];\n\t\t\tif(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);\n\t\t}\n\t}\n\tif(runtime) currentUpdateRuntime.push(runtime);\n\tif(waitingUpdateResolves[chunkId]) {\n\t\twaitingUpdateResolves[chunkId]();\n\t\twaitingUpdateResolves[chunkId] = undefined;\n\t}\n};\n\nvar currentUpdateChunks;\nvar currentUpdate;\nvar currentUpdateRemovedChunks;\nvar currentUpdateRuntime;\nfunction applyHandler(options) {\n\tif (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;\n\tcurrentUpdateChunks = undefined;\n\tfunction getAffectedModuleEffects(updateModuleId) {\n\t\tvar outdatedModules = [updateModuleId];\n\t\tvar outdatedDependencies = {};\n\n\t\tvar queue = outdatedModules.map(function (id) {\n\t\t\treturn {\n\t\t\t\tchain: [id],\n\t\t\t\tid: id\n\t\t\t};\n\t\t});\n\t\twhile (queue.length > 0) {\n\t\t\tvar queueItem = queue.pop();\n\t\t\tvar moduleId = queueItem.id;\n\t\t\tvar chain = queueItem.chain;\n\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\tif (\n\t\t\t\t!module ||\n\t\t\t\t(module.hot._selfAccepted && !module.hot._selfInvalidated)\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (module.hot._selfDeclined) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"self-declined\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (module.hot._main) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"unaccepted\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n\t\t\t\tvar parentId = module.parents[i];\n\t\t\t\tvar parent = __webpack_require__.c[parentId];\n\t\t\t\tif (!parent) continue;\n\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"declined\",\n\t\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\tparentId: parentId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n\t\t\t\t\tif (!outdatedDependencies[parentId])\n\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdelete outdatedDependencies[parentId];\n\t\t\t\toutdatedModules.push(parentId);\n\t\t\t\tqueue.push({\n\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\tid: parentId\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"accepted\",\n\t\t\tmoduleId: updateModuleId,\n\t\t\toutdatedModules: outdatedModules,\n\t\t\toutdatedDependencies: outdatedDependencies\n\t\t};\n\t}\n\n\tfunction addAllToSet(a, b) {\n\t\tfor (var i = 0; i < b.length; i++) {\n\t\t\tvar item = b[i];\n\t\t\tif (a.indexOf(item) === -1) a.push(item);\n\t\t}\n\t}\n\n\t// at begin all updates modules are outdated\n\t// the \"outdated\" status can propagate to parents if they don't accept the children\n\tvar outdatedDependencies = {};\n\tvar outdatedModules = [];\n\tvar appliedUpdate = {};\n\n\tvar warnUnexpectedRequire = function warnUnexpectedRequire(module) {\n\t\tconsole.warn(\n\t\t\t\"[HMR] unexpected require(\" + module.id + \") to disposed module\"\n\t\t);\n\t};\n\n\tfor (var moduleId in currentUpdate) {\n\t\tif (__webpack_require__.o(currentUpdate, moduleId)) {\n\t\t\tvar newModuleFactory = currentUpdate[moduleId];\n\t\t\t/** @type {TODO} */\n\t\t\tvar result;\n\t\t\tif (newModuleFactory) {\n\t\t\t\tresult = getAffectedModuleEffects(moduleId);\n\t\t\t} else {\n\t\t\t\tresult = {\n\t\t\t\t\ttype: \"disposed\",\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\t/** @type {Error|false} */\n\t\t\tvar abortError = false;\n\t\t\tvar doApply = false;\n\t\t\tvar doDispose = false;\n\t\t\tvar chainInfo = \"\";\n\t\t\tif (result.chain) {\n\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n\t\t\t}\n\t\t\tswitch (result.type) {\n\t\t\t\tcase \"self-declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\t\" in \" +\n\t\t\t\t\t\t\t\tresult.parentId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unaccepted\":\n\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n\t\t\t\t\tif (!options.ignoreUnaccepted)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"accepted\":\n\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n\t\t\t\t\tdoApply = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"disposed\":\n\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n\t\t\t\t\tdoDispose = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n\t\t\t}\n\t\t\tif (abortError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: abortError\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (doApply) {\n\t\t\t\tappliedUpdate[moduleId] = newModuleFactory;\n\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n\t\t\t\t\tif (__webpack_require__.o(result.outdatedDependencies, moduleId)) {\n\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (doDispose) {\n\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n\t\t\t}\n\t\t}\n\t}\n\tcurrentUpdate = undefined;\n\n\t// Store self accepted outdated modules to require them later by the module system\n\tvar outdatedSelfAcceptedModules = [];\n\tfor (var j = 0; j < outdatedModules.length; j++) {\n\t\tvar outdatedModuleId = outdatedModules[j];\n\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\tif (\n\t\t\tmodule &&\n\t\t\t(module.hot._selfAccepted || module.hot._main) &&\n\t\t\t// removed self-accepted modules should not be required\n\t\t\tappliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&\n\t\t\t// when called invalidate self-accepting is not possible\n\t\t\t!module.hot._selfInvalidated\n\t\t) {\n\t\t\toutdatedSelfAcceptedModules.push({\n\t\t\t\tmodule: outdatedModuleId,\n\t\t\t\trequire: module.hot._requireSelf,\n\t\t\t\terrorHandler: module.hot._selfAccepted\n\t\t\t});\n\t\t}\n\t}\n\n\tvar moduleOutdatedDependencies;\n\n\treturn {\n\t\tdispose: function () {\n\t\t\tcurrentUpdateRemovedChunks.forEach(function (chunkId) {\n\t\t\t\tdelete installedChunks[chunkId];\n\t\t\t});\n\t\t\tcurrentUpdateRemovedChunks = undefined;\n\n\t\t\tvar idx;\n\t\t\tvar queue = outdatedModules.slice();\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tvar moduleId = queue.pop();\n\t\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\t\tif (!module) continue;\n\n\t\t\t\tvar data = {};\n\n\t\t\t\t// Call dispose handlers\n\t\t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n\t\t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n\t\t\t\t\tdisposeHandlers[j].call(null, data);\n\t\t\t\t}\n\t\t\t\t__webpack_require__.hmrD[moduleId] = data;\n\n\t\t\t\t// disable module (this disables requires from this module)\n\t\t\t\tmodule.hot.active = false;\n\n\t\t\t\t// remove module from cache\n\t\t\t\tdelete __webpack_require__.c[moduleId];\n\n\t\t\t\t// when disposing there is no need to call dispose handler\n\t\t\t\tdelete outdatedDependencies[moduleId];\n\n\t\t\t\t// remove \"parents\" references from all children\n\t\t\t\tfor (j = 0; j < module.children.length; j++) {\n\t\t\t\t\tvar child = __webpack_require__.c[module.children[j]];\n\t\t\t\t\tif (!child) continue;\n\t\t\t\t\tidx = child.parents.indexOf(moduleId);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tchild.parents.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove outdated dependency from module children\n\t\t\tvar dependency;\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tmodule = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tidx = module.children.indexOf(dependency);\n\t\t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tapply: function (reportError) {\n\t\t\t// insert new code\n\t\t\tfor (var updateModuleId in appliedUpdate) {\n\t\t\t\tif (__webpack_require__.o(appliedUpdate, updateModuleId)) {\n\t\t\t\t\t__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// run new runtime modules\n\t\t\tfor (var i = 0; i < currentUpdateRuntime.length; i++) {\n\t\t\t\tcurrentUpdateRuntime[i](__webpack_require__);\n\t\t\t}\n\n\t\t\t// call accept handlers\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tvar callbacks = [];\n\t\t\t\t\t\tvar errorHandlers = [];\n\t\t\t\t\t\tvar dependenciesForCallbacks = [];\n\t\t\t\t\t\tfor (var j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tvar acceptCallback =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedDependencies[dependency];\n\t\t\t\t\t\t\tvar errorHandler =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedErrorHandlers[dependency];\n\t\t\t\t\t\t\tif (acceptCallback) {\n\t\t\t\t\t\t\t\tif (callbacks.indexOf(acceptCallback) !== -1) continue;\n\t\t\t\t\t\t\t\tcallbacks.push(acceptCallback);\n\t\t\t\t\t\t\t\terrorHandlers.push(errorHandler);\n\t\t\t\t\t\t\t\tdependenciesForCallbacks.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var k = 0; k < callbacks.length; k++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallbacks[k].call(null, moduleOutdatedDependencies);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tif (typeof errorHandlers[k] === \"function\") {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\terrorHandlers[k](err, {\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load self accepted modules\n\t\t\tfor (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {\n\t\t\t\tvar item = outdatedSelfAcceptedModules[o];\n\t\t\t\tvar moduleId = item.module;\n\t\t\t\ttry {\n\t\t\t\t\titem.require(moduleId);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (typeof item.errorHandler === \"function\") {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.errorHandler(err, {\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\tmodule: __webpack_require__.c[moduleId]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\ttype: \"self-accept-errored\",\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn outdatedModules;\n\t\t}\n\t};\n}\n__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {\n\tif (!currentUpdate) {\n\t\tcurrentUpdate = {};\n\t\tcurrentUpdateRuntime = [];\n\t\tcurrentUpdateRemovedChunks = [];\n\t\tapplyHandlers.push(applyHandler);\n\t}\n\tif (!__webpack_require__.o(currentUpdate, moduleId)) {\n\t\tcurrentUpdate[moduleId] = __webpack_require__.m[moduleId];\n\t}\n};\n__webpack_require__.hmrC.jsonp = function (\n\tchunkIds,\n\tremovedChunks,\n\tremovedModules,\n\tpromises,\n\tapplyHandlers,\n\tupdatedModulesList\n) {\n\tapplyHandlers.push(applyHandler);\n\tcurrentUpdateChunks = {};\n\tcurrentUpdateRemovedChunks = removedChunks;\n\tcurrentUpdate = removedModules.reduce(function (obj, key) {\n\t\tobj[key] = false;\n\t\treturn obj;\n\t}, {});\n\tcurrentUpdateRuntime = [];\n\tchunkIds.forEach(function (chunkId) {\n\t\tif (\n\t\t\t__webpack_require__.o(installedChunks, chunkId) &&\n\t\t\tinstalledChunks[chunkId] !== undefined\n\t\t) {\n\t\t\tpromises.push(loadUpdateChunk(chunkId, updatedModulesList));\n\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t} else {\n\t\t\tcurrentUpdateChunks[chunkId] = false;\n\t\t}\n\t});\n\tif (__webpack_require__.f) {\n\t\t__webpack_require__.f.jsonpHmr = function (chunkId, promises) {\n\t\t\tif (\n\t\t\t\tcurrentUpdateChunks &&\n\t\t\t\t__webpack_require__.o(currentUpdateChunks, chunkId) &&\n\t\t\t\t!currentUpdateChunks[chunkId]\n\t\t\t) {\n\t\t\t\tpromises.push(loadUpdateChunk(chunkId));\n\t\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t\t}\n\t\t};\n\t}\n};\n\n__webpack_require__.hmrM = () => {\n\tif (typeof fetch === \"undefined\") throw new Error(\"No browser support: need fetch API\");\n\treturn fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {\n\t\tif(response.status === 404) return; // no update available\n\t\tif(!response.ok) throw new Error(\"Failed to fetch update manifest \" + response.statusText);\n\t\treturn response.json();\n\t});\n};\n\n// no on chunks loaded\n\n// no jsonp function","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n",""],"names":["VersionComponent","MyApp","_ref","children","createVNode","null","Component","JobsList","MyHome","_Component","_inheritsLoose","props","call","_proto","prototype","render","createComponentVNode","version","showVersion","alert","createTextVNode","linkEvent","Job","register_new_job","JobForm","_this","state","was_send","job","handleChangeTitle","bind","_assertThisInitialized","handleChangeBudget","handleChangeDescription","handleSubmit","event","new_job","clone","setTitle","target","value","setState","setBudgetRange","setDescription","raw","then","result","new_job_id","id","window","location","href","preventDefault","title","description","default","get_job","JobRow","QuotationForm","QuotationsListForAdmin","JobPage","params","match","job_id","componentDidMount","_this2","console","log","_render_job","payer","Link","session_is_owner","data","url_job","text_owner","get_list_jobs","list_jobs","error","_render_jobs","jobs","jobElements","index","length","push","Quotation","register_new_quotation","XRPInput","quotation","handleUpdateTotalAmount","new_quotation","amount","setTotalAmount","redirect_url","QuotationPage","quotation_id","list_quotation_by_job","_this$props","payer_id","quotations","_render_quotes","quotes","quotesElements","quote","html","_this$props2","XRPValue","label","afterUpdate","handleChange","new_amount","trySetValueFromStr","componentDidUpdate","value_txt","on_dolars","BrowserRouter","Switch","Route","createBrowserHistory","browserHistory","App","NoMatch","_ref2","Home","_ref3","Users","_ref4","url","User","JobRouter","_ref5","_ref6","JSON","stringify","routes","main","document","getElementById","main_inferno"],"sourceRoot":""}